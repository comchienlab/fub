#!/usr/bin/env bash

# FUB - Fast Ubuntu Utility Toolkit
# Main executable entry point

set -euo pipefail

# Get the directory where this script is located
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly FUB_ROOT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Load core libraries
source "${FUB_ROOT_DIR}/lib/common.sh"

# Initialize basic colors for compatibility
export RESET=""
export BOLD=""
export DIM=""
export ITALIC=""
export UNDERLINE=""
export RED=""
export GREEN=""
export YELLOW=""
export BLUE=""
export MAGENTA=""
export CYAN=""
export WHITE=""
export GRAY=""
export HIGHLIGHT=""
export SUCCESS=""
export WARNING=""
export ERROR=""
export INFO=""
export DEBUG=""
export MUTED=""

# Load legacy compatibility first to detect legacy mode
if [[ -f "${FUB_ROOT_DIR}/lib/legacy/compatibility.sh" ]]; then
    source "${FUB_ROOT_DIR}/lib/legacy/compatibility.sh"
fi

source "${FUB_ROOT_DIR}/lib/theme.sh"
source "${FUB_ROOT_DIR}/lib/config.sh"
source "${FUB_ROOT_DIR}/lib/ui.sh"

# Initialize theme system
init_theme "minimal"

# Initialize legacy mode if needed
if [[ -f "${FUB_ROOT_DIR}/lib/legacy/legacy-mode.sh" ]]; then
    source "${FUB_ROOT_DIR}/lib/legacy/legacy-mode.sh"
    init_legacy_mode
fi

# FUB version and metadata (check if already defined)
[[ -z "${FUB_NAME:-}" ]] && readonly FUB_NAME="FUB - Fast Ubuntu Utility Toolkit"
[[ -z "${FUB_VERSION:-}" ]] && readonly FUB_VERSION="1.0.0"
[[ -z "${FUB_AUTHOR:-}" ]] && readonly FUB_AUTHOR="FUB Development Team"
[[ -z "${FUB_DESCRIPTION:-}" ]] && readonly FUB_DESCRIPTION="A comprehensive Ubuntu utility toolkit for system maintenance and development"

# Command categories
readonly CATEGORIES=(
    "system:System maintenance and configuration"
    "package:Package management operations"
    "service:System service management"
    "cleanup:System cleanup and maintenance"
    "network:Network configuration and diagnostics"
    "security:Security and authentication utilities"
    "development:Development tools and setup"
    "monitoring:System monitoring and diagnostics"
)

# Available modules
readonly MODULES=(
    "cleanup:System cleanup utilities"
    "system:System management tools"
    "network:Network configuration"
    "security:Security utilities"
)

# Default configuration
FUB_CONFIG_FILE="${FUB_CONFIG_FILE:-${FUB_CONFIG_DIR}/default.yaml}"
FUB_LOG_LEVEL="${FUB_LOG_LEVEL:-INFO}"
FUB_THEME="${FUB_THEME:-tokyo-night}"
FUB_INTERACTIVE="${FUB_INTERACTIVE:-true}"

# Command line options
VERBOSE=false
QUIET=false
DRY_RUN=false
HELP=false
VERSION=false

# Usage information
show_usage() {
    cat << EOF
${BOLD}${CYAN}$FUB_NAME${RESET}
${ITALIC}$FUB_DESCRIPTION${RESET}

${BOLD}Usage:${RESET}
    ${GREEN}fub${RESET} [${YELLOW}OPTIONS${RESET}] [${YELLOW}COMMAND${RESET}] [${YELLOW}ARGS${RESET}]

${BOLD}Options:${RESET}
    ${YELLOW}-h, --help${RESET}              Show this help message
    ${YELLOW}-v, --version${RESET}           Show version information
    ${YELLOW}-V, --verbose${RESET}           Enable verbose output
    ${YELLOW}-q, --quiet${RESET}             Suppress non-error output
    ${YELLOW}-n, --dry-run${RESET}           Show what would be done without executing
    ${YELLOW}-c, --config${RESET} FILE       Use custom configuration file
    ${YELLOW}-l, --log-level${RESET} LEVEL   Set logging level (DEBUG, INFO, WARN, ERROR, FATAL)
    ${YELLOW}-t, --theme${RESET} THEME       Set theme (default: tokyo-night)
    ${YELLOW}--no-interactive${RESET}        Run in non-interactive mode
    ${YELLOW}--legacy-mode${RESET}           Run in legacy mode for script compatibility
    ${YELLOW}--list-commands${RESET}         List all available commands
    ${YELLOW}--list-modules${RESET}          List all available modules

${BOLD}Commands:${RESET}
    ${YELLOW}cleanup${RESET}                 System cleanup and maintenance
        ${CYAN}temp${RESET}                  Clean temporary files
        ${CYAN}cache${RESET}                 Clean package caches
        ${CYAN}logs${RESET}                  Clean old log files
        ${CYAN}all${RESET}                   Clean all of the above

    ${YELLOW}system${RESET}                  System management
        ${CYAN}info${RESET}                  Show system information
        ${CYAN}update${RESET}                Update system packages
        ${CYAN}upgrade${RESET}               Upgrade system packages
        ${CYAN}status${RESET}                Show system status

    ${YELLOW}package${RESET}                 Package management
        ${CYAN}install${RESET} PKG           Install package
        ${CYAN}remove${RESET} PKG            Remove package
        ${CYAN}search${RESET} QUERY          Search packages
        ${CYAN}info${RESET} PKG              Show package information

    ${YELLOW}service${RESET}                 Service management
        ${CYAN}list${RESET}                  List all services
        ${CYAN}status${RESET} SERVICE        Show service status
        ${CYAN}start${RESET} SERVICE         Start service
        ${CYAN}stop${RESET} SERVICE          Stop service
        ${CYAN}restart${RESET} SERVICE       Restart service
        ${CYAN}enable${RESET} SERVICE        Enable service
        ${CYAN}disable${RESET} SERVICE       Disable service

    ${YELLOW}network${RESET}                 Network utilities
        ${CYAN}status${RESET}                Show network status
        ${CYAN}test${RESET}                  Test network connectivity
        ${CYAN}speed${RESET}                 Test network speed

    ${YELLOW}security${RESET}                Security utilities
        ${CYAN}scan${RESET}                  Security scan
        ${CYAN}audit${RESET}                 System audit
        ${CYAN}update${RESET}                Security updates

    ${YELLOW}scheduler${RESET}               Scheduled maintenance system
        ${CYAN}init${RESET}                  Initialize scheduler
        ${CYAN}status${RESET}                Show scheduler status
        ${CYAN}enable${RESET} PROFILE        Enable maintenance profile
        ${CYAN}disable${RESET} PROFILE       Disable maintenance profile
        ${CYAN}run${RESET} PROFILE           Run maintenance manually
        ${CYAN}list${RESET}                  List active profiles/timers
        ${CYAN}profiles${RESET}              List available profiles
        ${CYAN}history${RESET}               View maintenance history
        ${CYAN}stats${RESET}                 Show statistics
        ${CYAN}report${RESET}                Generate report
        ${CYAN}test${RESET}                  Test scheduler
        ${CYAN}suggest${RESET}               Get suggestions
        ${CYAN}ui${RESET}                    Interactive management
        ${CYAN}ui-menu${RESET}               Launch UI menu

    ${YELLOW}migration${RESET}               Migration and compatibility utilities
        ${CYAN}migrate-config${RESET}         Migrate configuration from legacy format
        ${CYAN}validate-script${RESET}        Validate script compatibility
        ${CYAN}migrate-script${RESET}         Migrate script to new format
        ${CYAN}detect-legacy${RESET}          Detect legacy configuration files

    ${YELLOW}rollback${RESET}                 System rollback and recovery
        ${CYAN}create-point${RESET}           Create rollback point
        ${CYAN}list-points${RESET}            List available rollback points
        ${CYAN}rollback${RESET} ID            Perform rollback to specified point
        ${CYAN}emergency${RESET}              Emergency rollback to last known good state

${BOLD}Examples:${RESET}
    ${GREEN}fub${RESET} cleanup temp         # Clean temporary files
    ${GREEN}fub${RESET} system update        # Update system packages
    ${GREEN}fub${RESET} package install git  # Install git package
    ${GREEN}fub${RESET} service status nginx # Check nginx status
    ${GREEN}fub${RESET} --dry-run cleanup all # Preview cleanup actions
    ${GREEN}fub${RESET} scheduler enable desktop    # Enable desktop maintenance profile
    ${GREEN}fub${RESET} scheduler status            # Show scheduler status
    ${GREEN}fub${RESET} scheduler ui-menu           # Launch scheduler UI
    ${GREEN}fub${RESET} migration migrate-config    # Migrate legacy configuration
    ${GREEN}fub${RESET} rollback create-point       # Create a rollback point
    ${GREEN}fub${RESET} --legacy-mode cleanup       # Run cleanup in legacy mode

${BOLD}Configuration:${RESET}
    Config file: ${CYAN}$FUB_CONFIG_FILE${RESET}
    Theme: ${CYAN}$FUB_THEME${RESET}
    Log level: ${CYAN}$FUB_LOG_LEVEL${RESET}

EOF
}

show_version() {
    cat << EOF
${BOLD}${CYAN}$FUB_NAME${RESET}
${ITALIC}$FUB_DESCRIPTION${RESET}

${BOLD}Version:${RESET} ${GREEN}$FUB_VERSION${RESET}
${BOLD}Author:${RESET} $FUB_AUTHOR
${BOLD}Website:${RESET} https://github.com/fub-toolkit/fub

${BOLD}System Information:${RESET}
${CYAN}Ubuntu Version:${RESET} $(get_ubuntu_version)
${CYAN}Kernel:${RESET} $(uname -r)
${CYAN}Architecture:${RESET} $(uname -m)
${CYAN}Shell:${RESET} $SHELL

EOF
}

list_commands() {
    echo ""
    echo "${BOLD}${CYAN}Available Commands:${RESET}"
    echo ""

    for category in "${CATEGORIES[@]}"; do
        local name="${category%%:*}"
        local desc="${category##*:}"
        echo "  ${YELLOW}${name}${RESET}"
        echo "    ${ITALIC}${desc}${RESET}"
        echo ""
    done

    echo ""
    echo "${BOLD}Module Commands:${RESET}"
    echo ""

    for module in "${MODULES[@]}"; do
        local name="${module%%:*}"
        local desc="${module##*:}"
        echo "  ${GREEN}${name}${RESET} ${DIM}(${name}.sh)${RESET}"
        echo "    ${desc}"
        echo ""
    done
}

list_modules() {
    echo ""
    echo "${BOLD}${CYAN}Available Modules:${RESET}"
    echo ""

    for module in "${MODULES[@]}"; do
        local name="${module%%:*}"
        local desc="${module##*:}"
        local module_file="${FUB_ROOT_DIR}/lib/${name}.sh"

        if file_exists "$module_file"; then
            echo "  ${GREEN}✓${RESET} ${YELLOW}${name}${RESET}"
            echo "    ${desc}"
            echo "    File: ${CYAN}${module_file}${RESET}"
        else
            echo "  ${RED}✗${RESET} ${YELLOW}${name}${RESET}"
            echo "    ${desc}"
            echo "    ${DIM}Module not found at: ${module_file}${RESET}"
        fi
        echo ""
    done
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                HELP=true
                shift
                ;;
            -v|--version)
                VERSION=true
                shift
                ;;
            -V|--verbose)
                VERBOSE=true
                FUB_LOG_LEVEL="DEBUG"
                shift
                ;;
            -q|--quiet)
                QUIET=true
                FUB_LOG_LEVEL="ERROR"
                shift
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -c|--config)
                FUB_CONFIG_FILE="$2"
                shift 2
                ;;
            -l|--log-level)
                FUB_LOG_LEVEL="$2"
                shift 2
                ;;
            -t|--theme)
                FUB_THEME="$2"
                shift 2
                ;;
            --no-interactive)
                FUB_INTERACTIVE=false
                shift
                ;;
            --legacy-mode)
                export FUB_LEGACY_MODE=true
                shift
                ;;
            --list-commands)
                list_commands
                exit 0
                ;;
            --list-modules)
                list_modules
                exit 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                # Command argument
                break
                ;;
        esac
    done

    # Return remaining arguments
    return 0
}

# Initialize FUB
initialize() {
    log_info "Initializing FUB - Fast Ubuntu Utility Toolkit v$FUB_VERSION"

    # Check if running on Ubuntu
    if ! is_ubuntu; then
        log_warn "FUB is optimized for Ubuntu. Some features may not work on other systems."
    fi

    # Load configuration
    load_config "$FUB_CONFIG_FILE"

    # Initialize theme
    init_theme "$FUB_THEME"

    # Check system requirements
    check_system_requirements

    log_info "FUB initialized successfully"
}

# Check system requirements
check_system_requirements() {
    log_debug "Checking system requirements..."

    # Check required commands
    local required_commands=("apt-get" "systemctl" "curl" "wget")
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done

    # Check minimum Ubuntu version (20.04)
    local ubuntu_version
    ubuntu_version=$(get_ubuntu_version)
    if version_compare "$ubuntu_version" "<" "20.04"; then
        log_warn "FUB is tested on Ubuntu 20.04+. You're running: $ubuntu_version"
    fi

    log_debug "System requirements check passed"
}

# Execute command
execute_command() {
    local command="$1"
    shift
    local args=("$@")

    log_debug "Executing command: $command with args: ${args[*]}"

    case "$command" in
        cleanup)
            source "${FUB_ROOT_DIR}/lib/cleanup/cleanup.sh"
            cleanup_command "${args[@]}"
            ;;
        system)
            system_command "${args[@]}"
            ;;
        package)
            package_command "${args[@]}"
            ;;
        service)
            service_command "${args[@]}"
            ;;
        network)
            network_command "${args[@]}"
            ;;
        security)
            security_command "${args[@]}"
            ;;
        scheduler)
            source "${FUB_ROOT_DIR}/lib/scheduler/scheduler.sh"
            scheduler_command "${args[@]}"
            ;;
        scheduler-ui)
            source "${FUB_ROOT_DIR}/lib/scheduler/scheduler-ui.sh"
            scheduler_ui_command "${args[@]}"
            ;;
        migration)
            migration_command "${args[@]}"
            ;;
        rollback)
            rollback_command "${args[@]}"
            ;;
        *)
            # Check for legacy commands first
            if command -v map_legacy_command >/dev/null 2>&1; then
                local mapped_command
                mapped_command=$(map_legacy_command "$command")
                if [[ "$mapped_command" != "$command" ]]; then
                    # Execute legacy command with mapping
                    execute_legacy_command "$command" "${args[@]}"
                    return $?
                fi
            fi

            # Try to load as module
            local module_file="${FUB_ROOT_DIR}/lib/${command}.sh"
            if file_exists "$module_file"; then
                log_info "Loading module: $command"
                source "$module_file"
                "${command}_command" "${args[@]}"
            else
                log_error "Unknown command: $command"
                echo ""
                echo "${RED}Error: Unknown command '$command'${RESET}"
                echo "Use '${YELLOW}fub --help${RESET}' to see available commands"
                echo "Use '${YELLOW}fub --list-commands${RESET}' to list all commands"
                echo ""
                exit 1
            fi
            ;;
    esac
}

# Built-in command handlers
system_command() {
    local subcommand="$1"

    case "$subcommand" in
        info)
            show_system_info
            ;;
        update)
            update_package_list
            ;;
        upgrade)
            update_package_list
            run_sudo apt-get upgrade -y
            ;;
        status)
            show_system_status
            ;;
        *)
            log_error "Unknown system command: $subcommand"
            exit 1
            ;;
    esac
}

package_command() {
    local subcommand="$1"
    shift

    case "$subcommand" in
        install)
            install_package "$1"
            ;;
        remove)
            remove_package "$1"
            ;;
        search)
            apt-cache search "$1"
            ;;
        info)
            apt-cache show "$1"
            ;;
        *)
            log_error "Unknown package command: $subcommand"
            exit 1
            ;;
    esac
}

service_command() {
    local subcommand="$1"
    local service="$2"

    case "$subcommand" in
        list)
            systemctl list-unit-files --type=service --state=enabled,disabled
            ;;
        status)
            systemctl status "$service"
            ;;
        start)
            start_service "$service"
            ;;
        stop)
            stop_service "$service"
            ;;
        restart)
            stop_service "$service"
            start_service "$service"
            ;;
        enable)
            enable_service "$service"
            ;;
        disable)
            disable_service "$service"
            ;;
        *)
            log_error "Unknown service command: $subcommand"
            exit 1
            ;;
    esac
}

network_command() {
    local subcommand="$1"

    case "$subcommand" in
        status)
            show_network_status
            ;;
        test)
            test_connectivity
            ;;
        speed)
            test_network_speed
            ;;
        *)
            log_error "Unknown network command: $subcommand"
            exit 1
            ;;
    esac
}

security_command() {
    local subcommand="$1"

    case "$subcommand" in
        scan)
            security_scan
            ;;
        audit)
            system_audit
            ;;
        update)
            security_updates
            ;;
        *)
            log_error "Unknown security command: $subcommand"
            exit 1
            ;;
    esac
}

# System information displays
show_system_info() {
    echo ""
    echo "${BOLD}${CYAN}System Information${RESET}"
    echo "=================="
    echo ""
    echo "${YELLOW}Operating System:${RESET} $(lsb_release -d 2>/dev/null | cut -f2 || echo "Unknown")"
    echo "${YELLOW}Ubuntu Version:${RESET} $(get_ubuntu_version)"
    echo "${YELLOW}Kernel Version:${RESET} $(uname -r)"
    echo "${YELLOW}Architecture:${RESET} $(uname -m)"
    echo "${YELLOW}Uptime:${RESET} $(uptime -p 2>/dev/null || echo "Unknown")"
    echo "${YELLOW}Load Average:${RESET} $(uptime | awk -F'load average:' '{print $2}' | xargs)"
    echo "${YELLOW}Memory Usage:${RESET} $(free -h | awk 'NR==2{printf "%.1f%% used (%s/%s)", $3*100/$2, $3, $2}')"
    echo "${YELLOW}Disk Usage:${RESET} $(df -h / | awk 'NR==2{printf "%s used (%s free)", $5, $4}')"
    echo ""
}

show_system_status() {
    show_system_info

    echo "${BOLD}${CYAN}Service Status${RESET}"
    echo "==============="
    echo ""

    local important_services=("ssh" "ufw" "cron" "systemd-journald")
    for service in "${important_services[@]}"; do
        if service_exists "${service}.service"; then
            local status_icon=""
            if is_service_active "$service"; then
                status_icon="${GREEN}●${RESET}"
            else
                status_icon="${RED}●${RESET}"
            fi
            echo "${status_icon} ${service}: $(systemctl is-active "$service" 2>/dev/null || echo "unknown")"
        fi
    done
    echo ""
}

show_network_status() {
    echo ""
    echo "${BOLD}${CYAN}Network Status${RESET}"
    echo "==============="
    echo ""

    # Network interfaces
    echo "${YELLOW}Network Interfaces:${RESET}"
    ip -brief addr show | awk '{print $1 " " $2 " " $3 " " $4}' | column -t

    echo ""
    echo "${YELLOW}Gateway:${RESET}"
    ip route | grep default | awk '{print $3}'

    echo ""
    echo "${YELLOW}DNS Servers:${RESET}"
    grep "nameserver" /etc/resolv.conf | awk '{print "  " $2}'

    echo ""
    echo "${YELLOW}Connectivity Test:${RESET}"
    if is_connected; then
        echo "  ${GREEN}✓${RESET} Internet connection available"
    else
        echo "  ${RED}✗${RESET} No internet connection"
    fi
    echo ""
}

test_connectivity() {
    echo ""
    echo "${BOLD}${CYAN}Network Connectivity Test${RESET}"
    echo "==========================="
    echo ""

    local test_hosts=("8.8.8.8" "1.1.1.1" "google.com" "github.com")

    for host in "${test_hosts[@]}"; do
        echo -n "Testing $host... "
        if ping -c 1 -W 3 "$host" >/dev/null 2>&1; then
            echo "${GREEN}✓${RESET}"
        else
            echo "${RED}✗${RESET}"
        fi
    done
    echo ""
}

test_network_speed() {
    echo ""
    echo "${BOLD}${CYAN}Network Speed Test${RESET}"
    echo "===================="
    echo ""

    if command_exists speedtest-cli; then
        speedtest-cli
    else
        echo "${YELLOW}Installing speedtest-cli...${RESET}"
        install_package speedtest-cli
        echo ""
        echo "Running speed test..."
        speedtest-cli
    fi
}

security_scan() {
    echo ""
    echo "${BOLD}${CYAN}Security Scan${RESET}"
    echo "============="
    echo ""

    # Check for common security tools
    local security_tools=("ufw" "fail2ban" "rkhunter" "chkrootkit")

    echo "${YELLOW}Security Tools Status:${RESET}"
    for tool in "${security_tools[@]}"; do
        if is_package_installed "$tool"; then
            echo "  ${GREEN}✓${RESET} $tool is installed"
        else
            echo "  ${YELLOW}○${RESET} $tool is not installed"
        fi
    done

    echo ""
    echo "${YELLOW}Firewall Status:${RESET}"
    if is_package_installed "ufw"; then
        ufw status verbose
    else
        echo "  ${YELLOW}UFW not installed${RESET}"
    fi
}

system_audit() {
    echo ""
    echo "${BOLD}${CYAN}System Audit${RESET}"
    echo "============"
    echo ""

    echo "${YELLOW}System Updates:${RESET}"
    if command_exists apt; then
        local updates
        updates=$(apt list --upgradable 2>/dev/null | grep -v "WARNING" | wc -l)
        echo "  Pending updates: $updates"
    fi

    echo ""
    echo "${YELLOW}Failed Services:${RESET}"
    systemctl --failed --no-pager

    echo ""
    echo "${YELLOW}Disk Space Critical:${RESET}"
    df -h | awk '$5+0 > 90 {print "  " $1 " " $5 " used on " $6}'
}

security_updates() {
    echo ""
    echo "${BOLD}${CYAN}Security Updates${RESET}"
    echo "================="
    echo ""

    update_package_list

    echo "Checking for security updates..."
    if command_exists unattended-upgrades; then
        sudo unattended-upgrades --dry-run -d
    else
        echo "Installing unattended-upgrades..."
        install_package unattended-upgrades
    fi
}

# Migration command handler
migration_command() {
    local action="${1:-help}"

    case "$action" in
        migrate-config)
            shift
            migrate_config_command "$@"
            ;;
        validate-script)
            shift
            validate_script_command "$@"
            ;;
        migrate-script)
            shift
            migrate_script_command "$@"
            ;;
        detect-legacy)
            detect_legacy_config_command
            ;;
        help|--help|-h)
            show_migration_help
            ;;
        *)
            log_error "Unknown migration command: $action"
            show_migration_help
            exit 1
            ;;
    esac
}

# Rollback command handler
rollback_command() {
    local action="${1:-help}"

    case "$action" in
        create-point)
            create_rollback_point_command
            ;;
        list-points)
            list_rollback_points_command
            ;;
        rollback)
            shift
            perform_rollback_command "$@"
            ;;
        emergency)
            emergency_rollback_command
            ;;
        help|--help|-h)
            show_rollback_help
            ;;
        *)
            log_error "Unknown rollback command: $action"
            show_rollback_help
            exit 1
            ;;
    esac
}

# Migration sub-commands
migrate_config_command() {
    local legacy_config="${1:-}"
    local new_config="${2:-}"

    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/config-migration.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/config-migration.sh"
        init_migration_system

        if [[ -n "$legacy_config" ]] && [[ -n "$new_config" ]]; then
            migrate_configuration "$legacy_config" "$new_config"
        else
            migrate_all_legacy_configs
        fi
    else
        log_error "Migration utilities not available"
        exit 1
    fi
}

validate_script_command() {
    local script_path="$1"

    if [[ -z "$script_path" ]]; then
        log_error "Script path required"
        echo "Usage: fub migration validate-script <script-path>"
        exit 1
    fi

    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/compatibility.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/compatibility.sh"
        validate_legacy_script "$script_path"
    else
        log_error "Compatibility utilities not available"
        exit 1
    fi
}

migrate_script_command() {
    local script_path="$1"

    if [[ -z "$script_path" ]]; then
        log_error "Script path required"
        echo "Usage: fub migration migrate-script <script-path>"
        exit 1
    fi

    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/legacy-mode.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/legacy-mode.sh"

        # Backup original script
        local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$script_path" "$backup_path"
        log_info "Script backed up to: $backup_path"

        # Perform script migration (simplified version)
        log_info "Migrating script: $script_path"

        # Apply legacy command mappings
        sed -i.bak 's/fub --clean/fub cleanup/g' "$script_path"
        sed -i 's/fub --temp/fub cleanup temp/g' "$script_path"
        sed -i 's/fub --cache/fub cleanup cache/g' "$script_path"
        sed -i 's/fub --logs/fub cleanup logs/g' "$script_path"
        sed -i 's/fub --all/fub cleanup all/g' "$script_path"
        sed -i 's/fub clean/fub cleanup/g' "$script_path"
        sed -i 's/fub --dry/fub --dry-run/g' "$script_path"

        log_success "Script migration completed"
        log_info "Original script backed up to: $backup_path"
    else
        log_error "Legacy mode utilities not available"
        exit 1
    fi
}

detect_legacy_config_command() {
    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/config-migration.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/config-migration.sh"

        local -a legacy_configs
        if readarray -t legacy_configs < <(detect_legacy_configs); then
            echo "Found legacy configuration files:"
            for config in "${legacy_configs[@]}"; do
                echo "  $config"
            done
            echo ""
            echo "Run 'fub migration migrate-config' to migrate these configurations"
        else
            echo "No legacy configuration files found"
        fi
    else
        log_error "Migration utilities not available"
        exit 1
    fi
}

# Rollback sub-commands
create_rollback_point_command() {
    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/rollback.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/rollback.sh"
        init_rollback_system

        local rollback_id
        rollback_id=$(create_rollback_point "manual-$(date +%Y%m%d_%H%M%S)" "Manual rollback point creation")
        log_success "Rollback point created: $rollback_id"
    else
        log_error "Rollback utilities not available"
        exit 1
    fi
}

list_rollback_points_command() {
    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/rollback.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/rollback.sh"
        list_rollbacks
    else
        log_error "Rollback utilities not available"
        exit 1
    fi
}

perform_rollback_command() {
    local rollback_id="$1"

    if [[ -z "$rollback_id" ]]; then
        log_error "Rollback ID required"
        echo "Usage: fub rollback rollback <rollback-id>"
        echo ""
        echo "Available rollback points:"
        list_rollback_points_command
        exit 1
    fi

    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/rollback.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/rollback.sh"
        init_rollback_system

        # Confirm rollback
        echo ""
        print_warning "This will rollback all changes made after the specified rollback point."
        print_warning "This action cannot be undone."
        echo ""
        read -p "Are you sure you want to continue? [y/N]: " confirm

        if [[ "$confirm" =~ ^[Yy] ]]; then
            perform_rollback "$rollback_id" "Manual rollback"
        else
            log_info "Rollback cancelled"
        fi
    else
        log_error "Rollback utilities not available"
        exit 1
    fi
}

emergency_rollback_command() {
    if [[ -f "${FUB_ROOT_DIR}/lib/legacy/rollback.sh" ]]; then
        source "${FUB_ROOT_DIR}/lib/legacy/rollback.sh"
        init_rollback_system

        print_warning "Performing emergency rollback to last known good state..."
        emergency_rollback "Manual emergency rollback"
    else
        log_error "Rollback utilities not available"
        exit 1
    fi
}

# Help functions for migration and rollback
show_migration_help() {
    cat << EOF
${BOLD}${CYAN}FUB Migration Utilities${RESET}
${ITALIC}Migrate and validate legacy configurations and scripts${RESET}

${BOLD}Usage:${RESET}
    ${GREEN}fub migration${RESET} [${YELLOW}ACTION${RESET}] [${YELLOW}ARGS${RESET}]

${BOLD}Actions:${RESET}
    ${YELLOW}migrate-config${RESET}           Migrate legacy configuration files
        ${CYAN}[legacy-config]${RESET}       Optional: specific legacy config file
        ${CYAN}[new-config]${RESET}          Optional: target new config file

    ${YELLOW}validate-script${RESET}         Validate script compatibility
        ${CYAN}<script-path>${RESET}          Path to script to validate

    ${YELLOW}migrate-script${RESET}          Migrate script to new command format
        ${CYAN}<script-path>${RESET}          Path to script to migrate

    ${YELLOW}detect-legacy${RESET}           Detect legacy configuration files

${BOLD}Examples:${RESET}
    ${GREEN}fub${RESET} migration migrate-config                    # Auto-migrate all configs
    ${GREEN}fub${RESET} migration migrate-config ~/.fubrc ~/.config/fub/config.yaml
    ${GREEN}fub${RESET} migration validate-script ./cleanup.sh     # Validate script
    ${GREEN}fub${RESET} migration migrate-script ./cleanup.sh      # Migrate script
    ${GREEN}fub${RESET} migration detect-legacy                    # Find legacy configs

EOF
}

show_rollback_help() {
    cat << EOF
${BOLD}${CYAN}FUB Rollback System${RESET}
${ITALIC}Create and manage system rollback points for safe upgrades${RESET}

${BOLD}Usage:${RESET}
    ${GREEN}fub rollback${RESET} [${YELLOW}ACTION${RESET}] [${YELLOW}ARGS${RESET}]

${BOLD}Actions:${RESET}
    ${YELLOW}create-point${RESET}             Create a new rollback point

    ${YELLOW}list-points${RESET}              List available rollback points

    ${YELLOW}rollback${RESET}                 Perform rollback to specified point
        ${CYAN}<rollback-id>${RESET}           ID of rollback point to restore

    ${YELLOW}emergency${RESET}                Emergency rollback to last known good state

${BOLD}Examples:${RESET}
    ${GREEN}fub${RESET} rollback create-point                    # Create rollback point
    ${GREEN}fub${RESET} rollback list-points                     # List rollback points
    ${GREEN}fub${RESET} rollback rollback auto-20231201_143022   # Rollback to point
    ${GREEN}fub${RESET} rollback emergency                       # Emergency rollback

${BOLD}Safety:${RESET}
    • Rollback points are created automatically before major operations
    • System state is fully backed up including configurations and packages
    • Emergency rollback is available if system becomes unstable
    • Always test rollbacks in non-production environments first

EOF
}

# Main execution
main() {
    # Parse command line arguments
    parse_args "$@"

    # Handle special flags
    if [[ "$HELP" == true ]]; then
        show_usage
        exit 0
    fi

    if [[ "$VERSION" == true ]]; then
        show_version
        exit 0
    fi

    # Initialize FUB
    initialize

    # If no command provided, show help
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 1
    fi

    # Execute command
    local command="$1"
    shift
    execute_command "$command" "$@"
}

# Execute main function with all arguments
main "$@"