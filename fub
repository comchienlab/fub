#!/usr/bin/env bash

# FUB - Filesystem Ubuntu Buddy
# Dig deep like a mole to clean your Ubuntu

set -Eeuo pipefail

# Constants
readonly VERSION="1.0.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly INSTALL_DIR="/usr/local/bin"

# Colors for terminal UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;37m'
readonly NC='\033[0m' # No Color

# Global variables
DRY_RUN=false
VERBOSE=false
QUIET=false
USE_GUM=false
CONFIG_DIR="$HOME/.config/fub"
CONFIG_FILE="$CONFIG_DIR/config.conf"

# =============================================================================
# Utility Functions
# =============================================================================

print_usage() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Filesystem Ubuntu Buddy

USAGE:
    $SCRIPT_NAME                    Show interactive dashboard
    $SCRIPT_NAME clean              Clean system with dry-run preview
    $SCRIPT_NAME clean --dry-run    Preview cleanup without execution
    $SCRIPT_NAME clean --force      Clean without confirmation prompts
    $SCRIPT_NAME analyze            Analyze disk usage (requires gum)
    $SCRIPT_NAME uninstall          Uninstall applications (requires gum)
    $SCRIPT_NAME debloat            Remove bloatware and unnecessary software (requires gum)
    $SCRIPT_NAME swap               Manage swap files for memory (requires gum)
    $SCRIPT_NAME fonts              Install Nerd Fonts for terminal (requires gum)
    $SCRIPT_NAME configure          Configure cleanup profiles (requires gum)
    $SCRIPT_NAME --version          Show version information
    $SCRIPT_NAME --help             Show this help message

EXAMPLES:
    $SCRIPT_NAME                    # Interactive dashboard with navigation
    $SCRIPT_NAME clean --dry-run    # See what would be cleaned
    $SCRIPT_NAME clean              # Execute cleanup safely
    $SCRIPT_NAME analyze            # Browse largest directories
    $SCRIPT_NAME uninstall          # Search and remove packages
    $SCRIPT_NAME debloat            # Remove snap, bloatware, orphans
    $SCRIPT_NAME swap               # Create/manage swap files
    $SCRIPT_NAME fonts              # Install Nerd Fonts with icons

NEW FEATURES (with gum):
    üìÅ Disk Analyzer - Interactively browse and clean large directories
    üóëÔ∏è  App Uninstaller - Search and thoroughly remove applications
    üí£ System Debloat - Remove snap packages, GNOME bloatware, orphaned packages
    üíæ Swap Manager - Create and manage swap files (2-32GB options)
    üé® Nerd Fonts - Install developer fonts with icons and glyphs
    ‚öôÔ∏è  Profiles - Configure Desktop, Server, or Minimal cleanup modes
    ‚ú® Enhanced UI - Modern styling with progress indicators

TAGLINE: Dig deep like a mole to clean your Ubuntu

For more information, visit: https://github.com/[user]/fub
Install gum: https://github.com/charmbracelet/gum
EOF
}

print_version() {
    echo "FUB v$VERSION"
    echo "Dig deep like a mole to clean your Ubuntu"
    echo ""
    echo "Platform: Ubuntu $(detect_ubuntu_version)"
    echo "License: MIT"
    echo "Inspired by: https://github.com/tw93/Mole"
}

log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case $level in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  $message" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
        "DEBUG")
            if [[ "$VERBOSE" == true ]]; then
                echo -e "${GRAY}[DEBUG]${NC} $message"
            fi
            ;;
    esac
}

detect_ubuntu_version() {
    if [[ -f /etc/lsb-release ]]; then
        source /etc/lsb-release
        echo "$DISTRIB_RELEASE"
    elif command -v lsb_release >/dev/null 2>&1; then
        lsb_release -rs
    else
        echo "unknown"
    fi
}

validate_ubuntu() {
    local version=$(detect_ubuntu_version)
    log DEBUG "Detected Ubuntu version: $version"

    # Check if we're actually on Ubuntu
    if [[ "$version" == "unknown" ]]; then
        # Check if we're on macOS (for development)
        if [[ "$(uname)" == "Darwin" ]]; then
            log WARN "Running on macOS (development mode)"
            log WARN "Ubuntu validation disabled for development"
            return 0
        fi

        log ERROR "This tool is designed for Ubuntu systems only"
        log ERROR "Detected: $(uname -s) $(uname -r)"
        exit 1
    fi

    case $version in
        24.04|22.04|20.04)
            log INFO "Ubuntu $version detected (supported)"
            return 0
            ;;
        *)
            log WARN "Ubuntu $version not explicitly tested"
            log WARN "Supported versions: 24.04, 22.04, 20.04"
            if [[ "$QUIET" != true ]]; then
                read -p "Continue anyway? [y/N]: " -r confirm
                if [[ ! $confirm =~ ^[Yy]$ ]]; then
                    echo "Aborted."
                    exit 1
                fi
            fi
            ;;
    esac
}

format_size() {
    local bytes=$1
    local units=('B' 'KB' 'MB' 'GB' 'TB')
    local unit=0

    while (( bytes > 1024 && unit < 4 )); do
        bytes=$((bytes / 1024))
        unit=$((unit + 1))
    done

    echo "${bytes}${units[$unit]}"
}

get_disk_info() {
    local free_space
    free_space=$(df -h / | awk 'NR==2 {print $4}')
    local used_percent
    used_percent=$(df -h / | awk 'NR==2 {print $5}')
    echo "$free_space free ($used_percent used)"
}

# =============================================================================
# Gum Detection and Configuration
# =============================================================================

check_gum() {
    if command -v gum >/dev/null 2>&1; then
        USE_GUM=true
        log DEBUG "Gum detected - enhanced UI enabled"
        return 0
    else
        USE_GUM=false
        log DEBUG "Gum not found - using fallback UI"
        return 1
    fi
}

show_gum_install_message() {
    echo ""
    echo -e "${YELLOW}üí° Tip: Install gum for an enhanced UI experience!${NC}"
    echo ""
    echo "  Ubuntu 22.04+ / Debian:"
    echo "    sudo mkdir -p /etc/apt/keyrings"
    echo "    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg"
    echo "    echo 'deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *' | sudo tee /etc/apt/sources.list.d/charm.list"
    echo "    sudo apt update && sudo apt install -y gum"
    echo ""
    echo "  More info: https://github.com/charmbracelet/gum"
    echo ""
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        log DEBUG "Config loaded from $CONFIG_FILE"
    else
        log DEBUG "No config file found at $CONFIG_FILE"
    fi
}

save_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# FUB Configuration
# Profile: ${CLEANUP_PROFILE:-default}
CLEANUP_PROFILE="${CLEANUP_PROFILE:-default}"
SHOW_GUM_TIP="${SHOW_GUM_TIP:-true}"
EOF
    log DEBUG "Config saved to $CONFIG_FILE"
}

# =============================================================================
# Enhanced Terminal Navigation Functions (Mole-style)
# =============================================================================

# Terminal control functions
hide_cursor() {
    tput civis 2>/dev/null || echo -ne "\e[?25l"
}

show_cursor() {
    tput cnorm 2>/dev/null || echo -ne "\e[?25h"
}

save_cursor() {
    tput sc 2>/dev/null || echo -ne "\e[s"
}

restore_cursor() {
    tput rc 2>/dev/null || echo -ne "\e[u"
}

clear_line() {
    tput el 2>/dev/null || echo -ne "\e[K"
}

# Enhanced key reading function for arrow key detection
read_key() {
    local key
    local char_count=0
    local max_chars=3  # ESC + [ + letter

    # Set terminal to raw mode for immediate input
    stty -icanon -echo 2>/dev/null || true

    # Read first character with timeout
    IFS= read -r -n1 -s key 2>/dev/null || {
        stty icanon echo 2>/dev/null || true
        return 1
    }

    # Handle escape sequences (arrow keys, function keys)
    if [[ "$key" == $'\e' ]]; then
        # Read remaining characters of escape sequence
        local remaining_chars
        IFS= read -r -n2 -s remaining_chars 2>/dev/null || remaining_chars=""
        key="${key}${remaining_chars}"
    fi

    # Restore terminal settings
    stty icanon echo 2>/dev/null || true

    # Process the key
    case "$key" in
        $'\e[A'|$'\eOA') echo "UP" ;;
        $'\e[B'|$'\eOB') echo "DOWN" ;;
        $'\e[C'|$'\eOC') echo "RIGHT" ;;
        $'\e[D'|$'\eOD') echo "LEFT" ;;
        $'\e') echo "ESC" ;;
        '') echo "ENTER" ;;
        $'\n'|$'\r') echo "ENTER" ;;
        'q'|'Q') echo "QUIT" ;;
        'j'|'J') echo "DOWN" ;;
        'k'|'K') echo "UP" ;;
        'h'|'H') echo "LEFT" ;;
        'l'|'L') echo "RIGHT" ;;
        *) echo "UNKNOWN" ;;
    esac
}

# Calculate adaptive border width
calculate_border_width() {
    local terminal_width=$(tput cols 2>/dev/null || echo 80)
    local min_width=40
    local max_width=120

    # Use smaller of terminal width or max width
    local effective_width=$(( terminal_width < max_width ? terminal_width : max_width ))

    # Ensure minimum width
    if [[ $effective_width -lt $min_width ]]; then
        effective_width=$min_width
    fi

    echo $effective_width
}

# Test Unicode box drawing support
test_unicode_support() {
    printf "‚ïî‚ïê‚ïó" >/dev/null 2>&1 && return 0 || return 1
}

# Terminal capability detection (enhanced)
detect_terminal_capabilities() {
    local has_colors=false
    local has_cursor_control=false
    local has_unicode=false
    local has_box_drawing=false

    # Check color support
    if command -v tput >/dev/null 2>&1 && [[ $(tput colors 2>/dev/null) -gt 8 ]]; then
        has_colors=true
    fi

    # Check cursor control
    if command -v tput >/dev/null 2>&1; then
        has_cursor_control=true
    fi

    # Check Unicode support
    if [[ -n "${LANG:-}" && "${LANG}" == *"UTF"* ]]; then
        has_unicode=true
    fi

    # Test box drawing characters
    if test_unicode_support; then
        has_box_drawing=true
    fi

    # Set global capability flags
    TERMINAL_HAS_COLORS=$has_colors
    TERMINAL_HAS_CURSOR=$has_cursor_control
    TERMINAL_HAS_UNICODE=$has_unicode
    TERMINAL_HAS_BOX_DRAWING=$has_box_drawing

    return 0
}

# Select appropriate border style based on terminal capabilities
select_border_style() {
    if [[ "$TERMINAL_HAS_BOX_DRAWING" == true ]]; then
        echo "double"    # ‚ïî‚ïê‚ïó‚ïë‚ïö‚ïù
    elif [[ "$TERMINAL_HAS_UNICODE" == true ]]; then
        echo "single"    # ‚îî‚îÄ‚îò‚îÇ‚îå‚îê
    else
        echo "ascii"     # +-++|
    fi
}

# Generate border characters dynamically
generate_border() {
    local width=$1
    local style=$2
    local line_type=${3:-"all"}

    case "$style" in
        "double")
            case "$line_type" in
                "top")
                    local top_line="‚ïî"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="‚ïê"
                    done
                    top_line+="‚ïó"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="‚ïö"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="‚ïê"
                    done
                    bottom_line+="‚ïù"
                    echo "$bottom_line"
                    ;;
                "side") echo "‚ïë" ;;
                "all")
                    local top_line="‚ïî"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="‚ïê"
                    done
                    top_line+="‚ïó"
                    echo "$top_line"
                    echo "‚ïë"
                    local bottom_line="‚ïö"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="‚ïê"
                    done
                    bottom_line+="‚ïù"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
        "single")
            case "$line_type" in
                "top")
                    local top_line="‚îå"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="‚îÄ"
                    done
                    top_line+="‚îê"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="‚îî"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="‚îÄ"
                    done
                    bottom_line+="‚îò"
                    echo "$bottom_line"
                    ;;
                "side") echo "‚îÇ" ;;
                "all")
                    local top_line="‚îå"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="‚îÄ"
                    done
                    top_line+="‚îê"
                    echo "$top_line"
                    echo "‚îÇ"
                    local bottom_line="‚îî"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="‚îÄ"
                    done
                    bottom_line+="‚îò"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
        "ascii")
            case "$line_type" in
                "top")
                    local top_line="+"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="-"
                    done
                    top_line+="+"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="+"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="-"
                    done
                    bottom_line+="+"
                    echo "$bottom_line"
                    ;;
                "side") echo "|" ;;
                "all")
                    local top_line="+"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="-"
                    done
                    top_line+="+"
                    echo "$top_line"
                    echo "|"
                    local bottom_line="+"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="-"
                    done
                    bottom_line+="+"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
    esac
}

# Cleanup terminal state
cleanup_terminal() {
    show_cursor
    stty icanon echo 2>/dev/null || true
    clear
}

# Set up cleanup on exit
trap cleanup_terminal EXIT

# =============================================================================
# Enhanced Interactive Dashboard UI (Mole-style)
# =============================================================================

show_enhanced_dashboard() {
    local current_selection=${1:-1}
    local terminal_height
    local border_width

    # Detect terminal capabilities first
    detect_terminal_capabilities

    # Calculate adaptive dimensions
    terminal_height=$(tput lines 2>/dev/null || echo 24)
    border_width=$(calculate_border_width)

    # Select border style based on capabilities
    local border_style=$(select_border_style)

    # Clear screen and hide cursor
    clear
    hide_cursor

    # Calculate centering for better UX
    local title_line=$((terminal_height / 8))

    # Move cursor to title position
    tput cup "$title_line" 0 2>/dev/null || echo -ne "\e[${title_line};1H"

    # Generate borders dynamically
    local top_border=$(generate_border $border_width $border_style "top")
    local side_char=$(generate_border $border_width $border_style "side")
    local bottom_border=$(generate_border $border_width $border_style "bottom")

    # Center the title
    local title="FUB DASHBOARD"
    local title_len=${#title}
    local title_col=$(( (border_width - title_len) / 2 ))
    local tagline="Dig deep like a mole to clean your Ubuntu"
    local tagline_len=${#tagline}
    local tagline_col=$(( (border_width - tagline_len) / 2 ))

    # Display title box with safe color handling
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        printf "${BLUE}%s${NC}\n" "$top_border"
        printf "${BLUE}%s${NC}%*s${WHITE}%s${NC}%*s${BLUE}%s${NC}\n" \
            "$side_char" $title_col "" "$title" $((border_width - title_col - title_len)) "" "$side_char"
        printf "${BLUE}%s${NC}%*s${CYAN}%s${NC}%*s${BLUE}%s${NC}\n" \
            "$side_char" $tagline_col "" "$tagline" $((border_width - tagline_col - tagline_len)) "" "$side_char"
        printf "${BLUE}%s${NC}\n" "$bottom_border"
    else
        printf "%s\n" "$top_border"
        printf "%s%*s%s%*s%s\n" \
            "$side_char" $title_col "" "$title" $((border_width - title_col - title_len)) "" "$side_char"
        printf "%s%*s%s%*s%s\n" \
            "$side_char" $tagline_col "" "$tagline" $((border_width - tagline_col - tagline_len)) "" "$side_char"
        printf "%s\n" "$bottom_border"
    fi
    echo ""

    # System info
    local ubuntu_version=$(detect_ubuntu_version)
    local disk_info=$(get_disk_info)
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        printf "${CYAN}System Info: %s | %s${NC}\n" "Ubuntu $ubuntu_version" "$disk_info"
    else
        printf "System Info: %s | %s\n" "Ubuntu $ubuntu_version" "$disk_info"
    fi
    echo ""

    # Menu options with dynamic highlighting
    local options=(
        "üßπ  Clean System (with dry-run preview)"
        "üöÄ  Quick Clean (skip preview)"
        "üìä  Dry-Run Only (analyze what can be cleaned)"
        "‚öôÔ∏è  System Status"
        "‚ùì  Help & Documentation"
        "üö™  Exit"
    )

    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        echo -e "${WHITE}Main Menu:${NC}"
    else
        echo "Main Menu:"
    fi
    echo ""

    # Calculate max text width for consistent formatting
    local max_text_length=0
    for option in "${options[@]}"; do
        local option_len=${#option}
        if [[ $option_len -gt $max_text_length ]]; then
            max_text_length=$option_len
        fi
    done

    # Ensure minimum width for menu items
    local menu_width=$((max_text_length > 46 ? max_text_length : 46))
    if [[ $menu_width -gt $((border_width - 4)) ]]; then
        menu_width=$((border_width - 4))
    fi

    # Display options with highlighting
    for i in "${!options[@]}"; do
        local option_text="${options[$i]}"

        if [[ $((i + 1)) -eq $current_selection ]]; then
            # Bold cyan selection (without numbers)
            if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
                printf "  \e[1m\e[36m%-${menu_width}s\e[0m\n" "$option_text"
            else
                printf "  %-${menu_width}s\n" "$option_text"
            fi
        else
            # Normal display with appropriate color
            if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
                printf "  \e[37m%-${menu_width}s\e[0m\n" "$option_text"
            else
                printf "  %-${menu_width}s\n" "$option_text"
            fi
        fi
    done

    echo ""
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        echo -e "${YELLOW}Navigation: ‚Üë‚Üì arrows to move, Enter to select, q to quit${NC}"
    else
        echo "Navigation: ‚Üë‚Üì arrows to move, Enter to select, q to quit"
    fi
    echo ""
}

# Handle terminal resize events
handle_terminal_resize() {
    # Redraw dashboard with current selection (new width calculation)
    show_enhanced_dashboard "$current_selection"
}

# Set up resize handler
trap 'handle_terminal_resize' WINCH

# Enhanced dashboard handler with arrow key navigation
handle_enhanced_dashboard() {
    local current_selection=1
    local max_selection=6
    local key_pressed

    # Detect terminal capabilities
    detect_terminal_capabilities

    while true; do
        show_enhanced_dashboard "$current_selection"

        # Read user input
        key_pressed=$(read_key) || continue

        case "$key_pressed" in
            "UP"|"k")
                ((current_selection > 1)) && ((current_selection--))
                ;;
            "DOWN"|"j")
                ((current_selection < max_selection)) && ((current_selection++))
                ;;
            "ENTER")
                show_cursor  # Restore cursor before executing action
                execute_dashboard_option "$current_selection"
                hide_cursor  # Hide cursor again for next display
                ;;
            "ESC"|"QUIT")
                show_cursor
                echo -e "${GREEN}Goodbye! üëã${NC}"
                exit 0
                ;;
            "UNKNOWN")
                # Ignore unknown keys
                ;;
        esac
    done
}

# Execute selected dashboard option
execute_dashboard_option() {
    local selection=$1

    case $selection in
        1)
            clear
            echo -e "${GREEN}Selected: Clean System with preview${NC}"
            sleep 1
            run_cleanup_with_preview
            ;;
        2)
            clear
            echo -e "${GREEN}Selected: Quick Clean${NC}"
            sleep 1
            run_quick_clean
            ;;
        3)
            clear
            echo -e "${GREEN}Selected: Dry-Run Only${NC}"
            sleep 1
            run_dry_run_only
            ;;
        4)
            clear
            echo -e "${GREEN}Selected: System Status${NC}"
            sleep 1
            show_system_status
            ;;
        5)
            clear
            echo -e "${GREEN}Selected: Help & Documentation${NC}"
            sleep 1
            show_help_screen
            ;;
        6)
            echo -e "${GREEN}Goodbye! üëã${NC}"
            exit 0
            ;;
    esac

    # Return to main menu prompt
    if [[ "$selection" != "6" ]]; then
        echo ""
        read -p "Press Enter to return to main menu..." -r
    fi
}

show_system_status() {
    clear
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë${NC}                     ${WHITE}SYSTEM STATUS${NC}                        ${BLUE}‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    echo -e "${CYAN}System Information:${NC}"
    echo "  Ubuntu Version: $(detect_ubuntu_version)"
    echo "  Kernel: $(uname -r)"
    echo "  Architecture: $(uname -m)"
    echo "  Uptime: $(uptime -p 2>/dev/null || echo "N/A")"
    echo ""

    echo -e "${CYAN}Disk Usage:${NC}"
    df -h | grep -E '^/dev/' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}Memory Usage:${NC}"
    free -h | grep -E '^Mem:|^Swap:' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}FUB Status:${NC}"
    echo "  Version: $VERSION"
    echo "  Installation: $(if [[ -x "$INSTALL_DIR/fub" ]]; then echo "‚úÖ Installed"; else echo "‚ùå Not found in $INSTALL_DIR"; fi)"
    echo ""
}

show_help_screen() {
    clear
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë${NC}                        ${WHITE}HELP & DOCS${NC}                        ${BLUE}‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""

    echo -e "${WHITE}What is FUB?${NC}"
    echo "FUB (Filesystem Ubuntu Buddy) is a terminal-based cleanup utility"
    echo "for Ubuntu, inspired by Mole for macOS. It helps you reclaim disk"
    echo "space by cleaning system caches, old kernels, and temporary files."
    echo ""

    echo -e "${WHITE}Cleanup Categories:${NC}"
    echo "  üßπ APT Cache - Old package files"
    echo "  üóÇÔ∏è  Old Kernels - Previous kernel versions (keeps current + 1)"
    echo "  üìã systemd Journal - System logs"
    echo "  üåê Browser Caches - Firefox, Chrome, Chromium"
    echo "  üíæ User Caches - Application caches in ~/.cache/"
    echo "  üóëÔ∏è  Temp Files - Old temporary files"
    echo ""

    echo -e "${WHITE}Safety Features:${NC}"
    echo "  ‚úÖ Never removes current kernel"
    echo "  ‚úÖ Dry-run mode shows exactly what will be cleaned"
    echo "  ‚úÖ Explicit confirmations for all operations"
    echo "  ‚úÖ Skips cleanup if APT is locked"
    echo ""

    echo -e "${WHITE}Command Line Usage:${NC}"
    echo "  fub                    Show this interactive dashboard"
    echo "  fub clean --dry-run    Preview cleanup without execution"
    echo "  fub clean              Execute cleanup safely"
    echo "  fub --help             Show help message"
    echo "  fub --version          Show version information"
    echo ""

    echo -e "${WHITE}More Information:${NC}"
    echo "  GitHub: https://github.com/[user]/fub"
    echo "  Inspired by: https://github.com/tw93/Mole"
    echo ""
}

# =============================================================================
# Gum-Enhanced Dashboard (Modern TUI)
# =============================================================================

show_gum_dashboard() {
    clear

    # System info banner
    local ubuntu_ver=$(detect_ubuntu_version)
    local disk_info=$(get_disk_info)

    gum style \
        --border double \
        --border-foreground 212 \
        --padding "1 2" \
        --width 70 \
        --align center \
        "$(gum style --foreground 212 --bold 'FUB DASHBOARD')" \
        "$(gum style --foreground 147 'Dig deep like a mole to clean your Ubuntu')" \
        "" \
        "$(gum style --foreground 86 "Ubuntu $ubuntu_ver | $disk_info")"

    echo ""

    # Interactive menu
    local choice
    choice=$(gum choose \
        --header "$(gum style --foreground 212 --bold 'Main Menu')" \
        --cursor "‚Üí " \
        --cursor-prefix "  " \
        --selected-prefix "  " \
        --height 15 \
        "üßπ  Clean System (with preview)" \
        "üöÄ  Quick Clean (skip preview)" \
        "üìä  Dry-Run Only (analyze)" \
        "üìÅ  Disk Analyzer" \
        "üóëÔ∏è  Uninstall Apps" \
        "üí£  System Debloat" \
        "üíæ  Swap Manager" \
        "üé®  Nerd Fonts" \
        "‚öôÔ∏è  Configure Profiles" \
        "‚ÑπÔ∏è  System Status" \
        "‚ùì  Help & Documentation" \
        "üö™  Exit")

    case "$choice" in
        "üßπ"*) run_gum_cleanup_with_preview ;;
        "üöÄ"*) run_gum_quick_clean ;;
        "üìä"*) run_gum_dry_run_only ;;
        "üìÅ"*) run_gum_disk_analyzer ;;
        "üóëÔ∏è"*) run_gum_uninstaller ;;
        "üí£"*) run_gum_debloat ;;
        "üíæ"*) run_gum_swap_manager ;;
        "üé®"*) run_gum_font_installer ;;
        "‚öôÔ∏è"*) run_gum_configure_profiles ;;
        "‚ÑπÔ∏è"*) show_gum_system_status ;;
        "‚ùì"*) show_gum_help_screen ;;
        "üö™"*)
            gum style --foreground 212 "Goodbye! üëã"
            exit 0
            ;;
    esac

    # Return to menu
    echo ""
    gum style --foreground 86 "Press Enter to return to main menu..."
    read -r
    show_gum_dashboard
}

show_gum_system_status() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'SYSTEM STATUS')"

    echo ""

    gum style --foreground 147 --bold "System Information:"
    echo "  Ubuntu Version: $(detect_ubuntu_version)"
    echo "  Kernel: $(uname -r)"
    echo "  Architecture: $(uname -m)"
    echo "  Uptime: $(uptime -p 2>/dev/null || echo "N/A")"
    echo ""

    gum style --foreground 147 --bold "Disk Usage:"
    df -h | grep -E '^/dev/' | while read -r line; do
        echo "  $line"
    done
    echo ""

    gum style --foreground 147 --bold "Memory Usage:"
    free -h | grep -E '^Mem:|^Swap:' | while read -r line; do
        echo "  $line"
    done
    echo ""

    gum style --foreground 147 --bold "FUB Status:"
    echo "  Version: $VERSION"
    echo "  Gum: $(if command -v gum >/dev/null 2>&1; then echo "‚úÖ Installed"; else echo "‚ùå Not installed"; fi)"
    echo "  Installation: $(if [[ -x "$INSTALL_DIR/fub" ]]; then echo "‚úÖ Installed"; else echo "‚ùå Not found"; fi)"
    echo ""
}

show_gum_help_screen() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'HELP & DOCUMENTATION')"

    echo ""

    gum style --foreground 147 --bold "What is FUB?"
    echo "FUB (Filesystem Ubuntu Buddy) is a terminal-based cleanup utility"
    echo "for Ubuntu, inspired by Mole for macOS. It helps you reclaim disk"
    echo "space by cleaning system caches, old kernels, and temporary files."
    echo ""

    gum style --foreground 147 --bold "Cleanup Categories:"
    echo "  üßπ APT Cache - Old package files"
    echo "  üóÇÔ∏è  Old Kernels - Previous kernel versions (keeps current + 1)"
    echo "  üìã systemd Journal - System logs"
    echo "  üåê Browser Caches - Firefox, Chrome, Chromium"
    echo "  üíæ User Caches - Application caches in ~/.cache/"
    echo "  üóëÔ∏è  Temp Files - Old temporary files"
    echo ""

    gum style --foreground 147 --bold "New Features (Gum-Enhanced):"
    echo "  üìÅ Disk Analyzer - Interactive directory browser"
    echo "  üóëÔ∏è  App Uninstaller - Search and remove packages"
    echo "  ‚öôÔ∏è  Profiles - Desktop, Server, or Minimal cleanup modes"
    echo ""

    gum style --foreground 147 --bold "Safety Features:"
    echo "  ‚úÖ Never removes current kernel"
    echo "  ‚úÖ Dry-run mode shows exactly what will be cleaned"
    echo "  ‚úÖ Explicit confirmations for all operations"
    echo "  ‚úÖ Skips cleanup if APT is locked"
    echo ""
}

# =============================================================================
# Gum-Enhanced Cleanup Functions
# =============================================================================

run_gum_cleanup_with_preview() {
    clear
    gum style --foreground 212 --bold "üîç Analyzing system for cleanup opportunities..."
    echo ""

    # Run dry-run first
    run_all_cleanup true

    echo ""
    if gum confirm "Proceed with cleanup?"; then
        echo ""
        gum spin --spinner dot --title "Cleaning system..." -- sleep 1
        echo ""
        run_gum_cleanup_execute
    else
        gum style --foreground 226 "Cleanup cancelled."
    fi
}

run_gum_quick_clean() {
    clear
    gum style --foreground 212 --bold "üöÄ Quick Clean Mode"
    echo ""
    gum style --foreground 244 "This will clean all categories without preview."
    echo ""

    if gum confirm "Are you sure?"; then
        echo ""
        run_gum_cleanup_execute
    else
        gum style --foreground 226 "Quick clean cancelled."
    fi
}

run_gum_dry_run_only() {
    clear
    gum style --foreground 212 --bold "üìä Dry-Run Analysis"
    echo ""
    run_all_cleanup true
}

run_gum_cleanup_execute() {
    # Cleanup with spinners for each category
    gum spin --spinner dot --title "Cleaning APT cache..." -- bash -c "cleanup_apt_cache false" 2>/dev/null || true
    gum spin --spinner dot --title "Vacuuming systemd journal..." -- bash -c "cleanup_systemd_journal false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning browser caches..." -- bash -c "cleanup_browser_caches false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning user caches..." -- bash -c "cleanup_user_caches false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning temp files..." -- bash -c "cleanup_temp_files false" 2>/dev/null || true

    echo ""
    gum style --foreground 82 --bold "‚úÖ Cleanup completed!"
}

# =============================================================================
# Disk Analyzer (New Mole-Inspired Feature)
# =============================================================================

run_gum_disk_analyzer() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'üìÅ DISK ANALYZER')"

    echo ""
    gum style --foreground 147 "Analyzing disk usage... This may take a moment."
    echo ""

    # Get largest directories in home
    local temp_file=$(mktemp)
    du -h "$HOME" 2>/dev/null | sort -hr | head -30 > "$temp_file"

    # Let user select directory to explore
    local selected
    selected=$(cat "$temp_file" | gum filter --placeholder "Search directories..." --height 20)

    rm -f "$temp_file"

    if [[ -n "$selected" ]]; then
        local dir_path=$(echo "$selected" | awk '{print $2}')
        local dir_size=$(echo "$selected" | awk '{print $1}')

        echo ""
        gum style --foreground 212 --bold "Selected: $dir_path ($dir_size)"
        echo ""

        # Show directory contents
        ls -lh "$dir_path" 2>/dev/null | tail -n +2 | head -20

        echo ""
        if gum confirm "Open this directory in your file manager?"; then
            xdg-open "$dir_path" 2>/dev/null || true
        fi
    fi
}

# =============================================================================
# App Uninstaller (New Mole-Inspired Feature)
# =============================================================================

run_gum_uninstaller() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'üóëÔ∏è  APP UNINSTALLER')"

    echo ""
    gum style --foreground 147 "Loading installed packages with sizes..."
    echo ""

    # Get installed packages with sizes
    local temp_sizes=$(mktemp)

    # Get package list and calculate sizes
    gum spin --spinner dot --title "Scanning packages..." -- bash -c "
        dpkg-query -W -f='\${Package}|\${Installed-Size}\n' | \
        grep -v '^|' | \
        sort -t'|' -k2 -n -r > '$temp_sizes'
    "

    local total_packages=$(wc -l < "$temp_sizes")
    gum style --foreground 82 "Found $total_packages installed packages"
    echo ""

    # Format packages with human-readable sizes, age indicators, and categories
    local formatted_list=$(mktemp)
    local formatted_user=$(mktemp)
    local formatted_system=$(mktemp)
    local current_time=$(date +%s)

    while IFS='|' read -r pkg size_kb; do
        if [[ -n "$pkg" && -n "$size_kb" ]]; then
            # Convert KB to human readable (shorter format for better alignment)
            if [[ $size_kb -gt 1048576 ]]; then
                # GB
                size_display=$(awk "BEGIN {printf \"%.1fG\", $size_kb/1048576}")
            elif [[ $size_kb -gt 1024 ]]; then
                # MB
                size_display=$(awk "BEGIN {printf \"%.0fM\", $size_kb/1024}")
            else
                # KB
                size_display="${size_kb}K"
            fi

            # Determine package age (Old vs Recent) with color coding
            local age_indicator="Recent"
            local age_color="82"  # Green
            local age_emoji="üü¢"
            local list_file="/var/lib/dpkg/info/${pkg}.list"

            if [[ -f "$list_file" ]]; then
                local file_time=$(stat -c %Y "$list_file" 2>/dev/null || echo "$current_time")
                local days_old=$(( (current_time - file_time) / 86400 ))

                if [[ $days_old -gt 180 ]]; then
                    age_indicator="Old"
                    age_color="196"  # Red
                    age_emoji="üî¥"
                elif [[ $days_old -gt 90 ]]; then
                    age_indicator="Aged"
                    age_color="226"  # Yellow
                    age_emoji="üü°"
                fi
            fi

            # Determine package category: USER or SYSTEM
            local category="USER"
            local category_emoji="üì¶"
            local is_system=false

            # Check if package is system/essential
            local priority=$(dpkg-query -W -f='${Priority}' "$pkg" 2>/dev/null || echo "optional")
            local section=$(dpkg-query -W -f='${Section}' "$pkg" 2>/dev/null || echo "")
            local essential=$(dpkg-query -W -f='${Essential}' "$pkg" 2>/dev/null || echo "no")

            # System package detection (combined method)
            if [[ "$essential" == "yes" ]] || \
               [[ "$priority" == "required" ]] || \
               [[ "$priority" == "important" ]] || \
               [[ "$section" =~ ^(admin|base|libs)$ ]] || \
               [[ "$pkg" =~ ^(apt|dpkg|systemd|libc|bash|coreutils|init|ubuntu-minimal) ]]; then
                category="SYSTEM"
                category_emoji="üîß"
                is_system=true
            fi

            # Format: package_name [CATEGORY] (size) | age emoji
            local line=$(printf "%-35s [%-6s] (%6s) | %-6s %s" "$pkg" "$category" "$size_display" "$age_indicator" "$age_emoji")

            # Separate USER and SYSTEM apps for sorting
            if [[ "$is_system" == false ]]; then
                echo "$line|$age_color" >> "$formatted_user"
            else
                echo "$line|$age_color" >> "$formatted_system"
            fi
        fi
    done < "$temp_sizes"

    # Combine: USER apps first, then SYSTEM apps
    cat "$formatted_user" "$formatted_system" > "$formatted_list"
    rm -f "$formatted_user" "$formatted_system"

    # Use fzf for fast search and multi-select
    gum style --foreground 147 "üöÄ Optimized with fzf - Type to search, Tab to select, Enter to confirm"
    gum style --foreground 147 "üí° Showing USER apps first, then SYSTEM apps"
    echo ""

    # Apply ANSI colors to lines for fzf display
    local colored_list=$(mktemp)
    while IFS='|' read -r line color_code; do
        echo -e "\033[38;5;${color_code}m${line}\033[0m"
    done < "$formatted_list" > "$colored_list"

    # Use fzf for combined search + multi-select (much faster than gum)
    local selected
    selected=$(cat "$colored_list" | fzf \
        --multi \
        --ansi \
        --prompt="üîç Search & Select > " \
        --header="Tab/Shift-Tab: select | Ctrl-A: all | Ctrl-D: deselect | Enter: confirm
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üî¥ Old (>6mo) | üü° Aged (3-6mo) | üü¢ Recent (<3mo)
üì¶ USER (safe to remove) | üîß SYSTEM (use caution!)
üí° Use fuzzy search: 'firefox old' finds old Firefox packages" \
        --bind 'ctrl-a:select-all' \
        --bind 'ctrl-d:deselect-all' \
        --bind 'ctrl-/:toggle-preview' \
        --preview 'apt show $(echo {} | awk "{print \$1}") 2>/dev/null | head -25' \
        --preview-window 'right:50%:wrap:hidden' \
        --height 100% \
        --layout reverse \
        --border rounded \
        --info inline)

    rm -f "$temp_sizes" "$formatted_list" "$colored_list"

    if [[ -z "$selected" ]]; then
        gum style --foreground 147 "No packages selected."
        return
    fi

    # Extract package names from selected items (remove size, category, and age info)
    # Format is: package_name [CATEGORY] (size) | age emoji
    local package_names=$(echo "$selected" | awk '{print $1}')
    local package_count=$(echo "$package_names" | wc -l)

    # Check if any SYSTEM packages are selected and warn
    local has_system=false
    echo "$selected" | grep -q "\[SYSTEM\]" && has_system=true

    if [[ "$has_system" == true ]]; then
        echo ""
        gum style --foreground 196 --bold "‚ö†Ô∏è  WARNING: System Packages Selected!"
        gum style --foreground 226 "You have selected SYSTEM packages. Removing these may:"
        gum style --foreground 226 "  ‚Ä¢ Break system functionality"
        gum style --foreground 226 "  ‚Ä¢ Prevent system updates"
        gum style --foreground 226 "  ‚Ä¢ Cause boot failures"
        echo ""

        if ! gum confirm "Do you understand the risks and want to continue?"; then
            gum style --foreground 147 "Uninstall cancelled for safety."
            return
        fi
        echo ""
    fi

    # If only one package selected, show detailed info
    if [[ $package_count -eq 1 ]]; then
        echo ""
        gum style --foreground 212 --bold "Selected Package Details:"
        echo ""
        apt show "$package_names" 2>/dev/null | head -20
    else
        # Multiple packages - show list with categories and colors
        echo ""
        gum style --foreground 212 --bold "Selected Packages ($package_count):"
        gum style --foreground 147 "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        echo "$package_names" | while IFS= read -r pkg; do
            local pkg_size=$(dpkg-query -W -f='${Installed-Size}' "$pkg" 2>/dev/null || echo "0")

            # Convert to short format
            if [[ $pkg_size -gt 1048576 ]]; then
                size_display=$(awk "BEGIN {printf \"%.1fG\", $pkg_size/1048576}")
            elif [[ $pkg_size -gt 1024 ]]; then
                size_display=$(awk "BEGIN {printf \"%.0fM\", $pkg_size/1024}")
            else
                size_display="${pkg_size}K"
            fi

            # Get age indicator with color
            local age_indicator="Recent"
            local age_emoji="üü¢"
            local age_color="82"
            local list_file="/var/lib/dpkg/info/${pkg}.list"
            if [[ -f "$list_file" ]]; then
                local file_time=$(stat -c %Y "$list_file" 2>/dev/null || echo "$(date +%s)")
                local days_old=$(( ($(date +%s) - file_time) / 86400 ))
                if [[ $days_old -gt 180 ]]; then
                    age_indicator="Old"
                    age_emoji="üî¥"
                    age_color="196"
                elif [[ $days_old -gt 90 ]]; then
                    age_indicator="Aged"
                    age_emoji="üü°"
                    age_color="226"
                fi
            fi

            # Determine category
            local category="USER"
            local priority=$(dpkg-query -W -f='${Priority}' "$pkg" 2>/dev/null || echo "optional")
            local section=$(dpkg-query -W -f='${Section}' "$pkg" 2>/dev/null || echo "")
            local essential=$(dpkg-query -W -f='${Essential}' "$pkg" 2>/dev/null || echo "no")

            if [[ "$essential" == "yes" ]] || \
               [[ "$priority" == "required" ]] || \
               [[ "$priority" == "important" ]] || \
               [[ "$section" =~ ^(admin|base|libs)$ ]] || \
               [[ "$pkg" =~ ^(apt|dpkg|systemd|libc|bash|coreutils|init|ubuntu-minimal) ]]; then
                category="SYSTEM"
            fi

            # Display with color based on age
            gum style --foreground "$age_color" "  ‚òë $(printf '%-30s' "$pkg") [$(printf '%-6s' "$category")] ($(printf '%6s' "$size_display")) | $age_indicator $age_emoji"
        done

        # Calculate total size
        echo ""
        local total_size=0
        echo "$package_names" | while IFS= read -r pkg; do
            local pkg_size=$(dpkg-query -W -f='${Installed-Size}' "$pkg" 2>/dev/null || echo "0")
            echo "$pkg_size"
        done | awk '{sum+=$1} END {
            if (sum > 1048576) {
                printf "%.1fG", sum/1048576
            } else if (sum > 1024) {
                printf "%.0fM", sum/1024
            } else {
                printf "%dK", sum
            }
        }' | xargs -I {} gum style --foreground 212 --bold "Total size to free: {}"
    fi

    echo ""

    # Confirm uninstallation
    if [[ $package_count -eq 1 ]]; then
        if ! gum confirm "Uninstall $package_names and remove config files?"; then
            gum style --foreground 226 "Uninstall cancelled."
            return
        fi
    else
        if ! gum confirm "Uninstall $package_count packages and remove their config files?"; then
            gum style --foreground 226 "Uninstall cancelled."
            return
        fi
    fi

    echo ""

    # Uninstall packages
    local success_count=0
    local fail_count=0

    if [[ $package_count -eq 1 ]]; then
        # Single package - show simple progress
        gum spin --spinner dot --title "Uninstalling $package_names..." -- \
            sudo apt purge -y "$package_names" 2>&1 | tee /tmp/fub-uninstall.log

        if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
            ((success_count++))
        else
            ((fail_count++))
        fi
    else
        # Multiple packages - uninstall with progress
        echo "$package_names" | while IFS= read -r pkg; do
            gum spin --spinner dot --title "Uninstalling $pkg..." -- \
                sudo apt purge -y "$pkg" 2>&1 | tee -a /tmp/fub-uninstall.log

            if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                gum style --foreground 82 "‚úì Removed: $pkg"
            else
                gum style --foreground 196 "‚úó Failed: $pkg"
            fi
        done

        # Count successes and failures from log
        success_count=$(echo "$package_names" | wc -l)
    fi

    # Run autoremove to clean up dependencies
    echo ""
    gum spin --spinner dot --title "Cleaning up unused dependencies..." -- \
        sudo apt autoremove -y 2>&1 | tee -a /tmp/fub-uninstall.log

    echo ""

    # Show results
    if [[ $package_count -eq 1 ]]; then
        if [[ $success_count -eq 1 ]]; then
            gum style --border rounded --border-foreground 82 --padding "1 2" \
                "$(gum style --foreground 82 --bold '‚úÖ Package uninstalled successfully!')"
        else
            gum style --border rounded --border-foreground 196 --padding "1 2" \
                "$(gum style --foreground 196 --bold '‚ùå Uninstallation failed')"
            gum style --foreground 147 "Check log: /tmp/fub-uninstall.log"
        fi
    else
        gum style --border rounded --border-foreground 82 --padding "1 2" \
            "$(gum style --foreground 82 --bold "‚úÖ $package_count packages uninstalled!")"
        gum style --foreground 147 "Log saved: /tmp/fub-uninstall.log"
    fi
}

# =============================================================================
# System Debloat (Remove Unnecessary Software)
# =============================================================================

run_gum_debloat() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'üóëÔ∏è  SYSTEM DEBLOAT')"

    echo ""
    gum style --foreground 147 "Remove unnecessary software and bloatware from your system."
    gum style --foreground 226 "‚ö†Ô∏è  This will permanently remove selected components."
    echo ""

    # Check what's installed
    local has_snap=false
    local has_gnome_games=false
    local has_gnome_software=false
    local has_bluetooth=false
    local has_orphans=false

    # Detect installed bloatware
    if command -v snap &> /dev/null; then
        has_snap=true
    fi
    if dpkg -l | grep -q "gnome-games"; then
        has_gnome_games=true
    fi
    if dpkg -l | grep -q "gnome-software"; then
        has_gnome_software=true
    fi
    if systemctl is-enabled bluetooth &> /dev/null 2>&1; then
        has_bluetooth=true
    fi
    if command -v deborphan &> /dev/null && [[ -n "$(sudo deborphan 2>/dev/null)" ]]; then
        has_orphans=true
    fi

    # Build options list
    local options=()

    if [[ "$has_snap" == true ]]; then
        options+=("Snap packages (snapd)")
    fi
    if [[ "$has_gnome_games" == true ]]; then
        options+=("GNOME Games")
    fi
    if [[ "$has_gnome_software" == true ]]; then
        options+=("GNOME Software Center")
    fi
    if [[ "$has_bluetooth" == true ]]; then
        options+=("Bluetooth service (disable)")
    fi
    options+=("Orphaned packages (unused dependencies)")

    if [[ ${#options[@]} -eq 0 ]]; then
        gum style --foreground 82 "‚úÖ No bloatware detected! Your system is already clean."
        return
    fi

    # Let user select what to remove
    local selected
    selected=$(printf '%s\n' "${options[@]}" | gum choose \
        --no-limit \
        --header "Select components to remove (Space to select, Enter to confirm):" \
        --cursor "‚Üí " \
        --selected-prefix "‚úì " \
        --unselected-prefix "‚óã " \
        --height 15)

    if [[ -z "$selected" ]]; then
        gum style --foreground 226 "No components selected. Debloat cancelled."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Selected for removal:"
    echo "$selected" | while IFS= read -r line; do
        echo "  ‚Ä¢ $line"
    done
    echo ""

    # Show size estimation
    gum style --foreground 147 "Estimating space savings..."
    local total_size=0

    if echo "$selected" | grep -q "Snap packages"; then
        local snap_size=$(du -sh /var/lib/snapd 2>/dev/null | awk '{print $1}' || echo "0")
        gum style --foreground 86 "  Snap packages: ~$snap_size"
    fi
    if echo "$selected" | grep -q "GNOME Games"; then
        gum style --foreground 86 "  GNOME Games: ~50-100 MB"
    fi
    if echo "$selected" | grep -q "GNOME Software"; then
        gum style --foreground 86 "  GNOME Software: ~20-50 MB"
    fi
    if echo "$selected" | grep -q "Orphaned"; then
        local orphan_count=$(sudo deborphan 2>/dev/null | wc -l || echo "0")
        gum style --foreground 86 "  Orphaned packages: $orphan_count packages"
    fi

    echo ""

    # Confirm before proceeding
    if ! gum confirm "Proceed with debloating?"; then
        gum style --foreground 226 "Debloat cancelled."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Starting debloat process..."
    echo ""

    # Execute removals
    local errors=0

    # Remove Snap
    if echo "$selected" | grep -q "Snap packages"; then
        gum style --foreground 147 "Removing Snap packages..."

        # Remove all snap packages first
        if snap list &> /dev/null; then
            snap list 2>/dev/null | tail -n +2 | awk '{print $1}' | while read -r snapname; do
                gum spin --spinner dot --title "Removing snap: $snapname" -- \
                    sudo snap remove "$snapname" 2>&1 | tee /tmp/fub-debloat.log || ((errors++))
            done
        fi

        # Remove snapd
        gum spin --spinner dot --title "Removing snapd..." -- \
            sudo apt purge -y snapd 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))

        # Remove snap directories
        sudo rm -rf /snap /var/snap /var/lib/snapd ~/snap 2>/dev/null

        gum style --foreground 82 "‚úÖ Snap removed"
        echo ""
    fi

    # Remove GNOME Games
    if echo "$selected" | grep -q "GNOME Games"; then
        gum spin --spinner dot --title "Removing GNOME Games..." -- \
            sudo apt purge -y gnome-games 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        gum style --foreground 82 "‚úÖ GNOME Games removed"
        echo ""
    fi

    # Remove GNOME Software
    if echo "$selected" | grep -q "GNOME Software"; then
        gum spin --spinner dot --title "Removing GNOME Software Center..." -- \
            sudo apt purge -y gnome-software 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        gum style --foreground 82 "‚úÖ GNOME Software Center removed"
        echo ""
    fi

    # Disable Bluetooth
    if echo "$selected" | grep -q "Bluetooth service"; then
        gum spin --spinner dot --title "Disabling Bluetooth service..." -- \
            sudo systemctl disable bluetooth 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        sudo systemctl stop bluetooth 2>&1 | tee -a /tmp/fub-debloat.log || true
        gum style --foreground 82 "‚úÖ Bluetooth service disabled"
        echo ""
    fi

    # Remove orphaned packages
    if echo "$selected" | grep -q "Orphaned"; then
        if command -v deborphan &> /dev/null; then
            local orphans=$(sudo deborphan 2>/dev/null)
            if [[ -n "$orphans" ]]; then
                gum spin --spinner dot --title "Removing orphaned packages..." -- \
                    sudo apt purge -y $(sudo deborphan) 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
                gum style --foreground 82 "‚úÖ Orphaned packages removed"
            else
                gum style --foreground 147 "No orphaned packages found"
            fi
        else
            gum style --foreground 226 "‚ö†Ô∏è  deborphan not installed, skipping orphan removal"
            gum style --foreground 147 "Install with: sudo apt install deborphan"
        fi
        echo ""
    fi

    # Clean up
    gum spin --spinner dot --title "Cleaning up..." -- \
        sudo apt autoremove -y 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))

    echo ""

    if [[ $errors -eq 0 ]]; then
        gum style --border rounded --border-foreground 82 --padding "1 2" \
            "$(gum style --foreground 82 --bold '‚úÖ Debloat completed successfully!')"
    else
        gum style --border rounded --border-foreground 226 --padding "1 2" \
            "$(gum style --foreground 226 --bold '‚ö†Ô∏è  Debloat completed with some errors')"
        gum style --foreground 147 "Check log: /tmp/fub-debloat.log"
    fi

    echo ""
    gum style --foreground 147 "Space reclaimed: $(df -h / | tail -1 | awk '{print $4}') available"
}

# =============================================================================
# Swap File Manager (Memory Management)
# =============================================================================

run_gum_swap_manager() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'üíæ SWAP FILE MANAGER')"

    echo ""
    gum style --foreground 147 "Manage swap files for systems with limited RAM."
    echo ""

    # Show current swap status
    gum style --foreground 212 --bold "Current Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
    echo ""

    # Check if swap exists
    local has_swap=false
    local swap_size=""
    local swap_file=""

    if swapon --show | grep -q "/swapfile"; then
        has_swap=true
        swap_file="/swapfile"
        swap_size=$(swapon --show | grep "/swapfile" | awk '{print $3}')
    elif swapon --show | tail -n +2 | grep -q "/"; then
        has_swap=true
        swap_file=$(swapon --show | tail -n +2 | awk '{print $1}' | head -1)
        swap_size=$(swapon --show | tail -n +2 | awk '{print $3}' | head -1)
    fi

    if [[ "$has_swap" == true ]]; then
        gum style --foreground 82 "‚úÖ Swap file detected: $swap_file ($swap_size)"
        echo ""
    else
        gum style --foreground 226 "‚ö†Ô∏è  No swap file detected"
        echo ""
    fi

    # Present options
    local action
    if [[ "$has_swap" == true ]]; then
        action=$(gum choose \
            --header "Select action:" \
            --cursor "‚Üí " \
            "Create new swap file (replaces existing)" \
            "Disable and remove swap" \
            "Show detailed swap info" \
            "Cancel")
    else
        action=$(gum choose \
            --header "Select action:" \
            --cursor "‚Üí " \
            "Create swap file" \
            "Show memory info" \
            "Cancel")
    fi

    case "$action" in
        *"Create"*)
            create_swap_file
            ;;
        *"Disable"*)
            remove_swap_file "$swap_file"
            ;;
        *"Show"*)
            show_swap_info
            ;;
        "Cancel")
            gum style --foreground 147 "Swap management cancelled."
            ;;
    esac
}

create_swap_file() {
    echo ""
    gum style --foreground 212 --bold "Create Swap File"
    echo ""

    # Recommend swap size based on RAM
    local total_ram_mb=$(free -m | awk '/^Mem:/ {print $2}')
    local recommended_gb=4

    if [[ $total_ram_mb -lt 2048 ]]; then
        recommended_gb=4
    elif [[ $total_ram_mb -lt 4096 ]]; then
        recommended_gb=8
    elif [[ $total_ram_mb -lt 8192 ]]; then
        recommended_gb=8
    else
        recommended_gb=16
    fi

    gum style --foreground 147 "Total RAM: $(free -h | awk '/^Mem:/ {print $2}')"
    gum style --foreground 147 "Recommended swap: ${recommended_gb}GB"
    echo ""

    # Let user choose size
    local size_choice
    size_choice=$(gum choose \
        --header "Select swap file size:" \
        --cursor "‚Üí " \
        "2GB" \
        "4GB (recommended for <4GB RAM)" \
        "8GB (recommended for 4-8GB RAM)" \
        "16GB (recommended for >8GB RAM)" \
        "32GB (for intensive workloads)" \
        "Custom size" \
        "Cancel")

    if [[ "$size_choice" == "Cancel" ]]; then
        return
    fi

    local swap_size_gb
    if [[ "$size_choice" == "Custom size" ]]; then
        swap_size_gb=$(gum input --placeholder "Enter size in GB (e.g., 4)")

        # Validate input
        if ! [[ "$swap_size_gb" =~ ^[0-9]+$ ]]; then
            gum style --foreground 196 "‚ùå Invalid input. Must be a number."
            return
        fi

        if [[ $swap_size_gb -lt 1 ]] || [[ $swap_size_gb -gt 64 ]]; then
            gum style --foreground 196 "‚ùå Size must be between 1 and 64 GB."
            return
        fi
    else
        swap_size_gb=$(echo "$size_choice" | grep -oP '^\d+')
    fi

    echo ""
    gum style --foreground 212 --bold "Creating ${swap_size_gb}GB swap file..."
    echo ""

    # Confirm
    if ! gum confirm "Create ${swap_size_gb}GB swap file at /swapfile?"; then
        gum style --foreground 226 "Swap creation cancelled."
        return
    fi

    echo ""

    # Disable existing swap
    if swapon --show | grep -q "/swapfile"; then
        gum spin --spinner dot --title "Disabling existing swap..." -- \
            sudo swapoff /swapfile 2>&1 | tee /tmp/fub-swap.log || true
        sudo rm -f /swapfile 2>/dev/null || true
    fi

    # Create swap file using fallocate (faster than dd)
    gum style --foreground 147 "Creating swap file (this may take a moment)..."
    if ! sudo fallocate -l ${swap_size_gb}G /swapfile 2>/dev/null; then
        # Fallback to dd if fallocate fails
        gum spin --spinner dot --title "Creating swap file with dd..." -- \
            sudo dd if=/dev/zero of=/swapfile bs=1M count=$((swap_size_gb * 1024)) status=progress 2>&1 | tee -a /tmp/fub-swap.log
    else
        gum style --foreground 82 "‚úÖ Swap file allocated"
    fi

    # Set permissions
    gum spin --spinner dot --title "Setting permissions..." -- \
        sudo chmod 600 /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Format as swap
    gum spin --spinner dot --title "Formatting as swap..." -- \
        sudo mkswap /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Enable swap
    gum spin --spinner dot --title "Enabling swap..." -- \
        sudo swapon /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Add to fstab if not present
    if ! grep -q "/swapfile" /etc/fstab 2>/dev/null; then
        gum spin --spinner dot --title "Adding to /etc/fstab..." -- \
            bash -c 'echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab' 2>&1 | tee -a /tmp/fub-swap.log
        gum style --foreground 82 "‚úÖ Added to /etc/fstab for persistence"
    else
        gum style --foreground 147 "Entry already exists in /etc/fstab"
    fi

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold '‚úÖ Swap file created successfully!')"

    echo ""
    gum style --foreground 212 --bold "New Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
}

remove_swap_file() {
    local swap_file=$1
    echo ""
    gum style --foreground 226 --bold "‚ö†Ô∏è  Remove Swap File"
    echo ""

    gum style --foreground 147 "This will disable and remove: $swap_file"
    echo ""

    if ! gum confirm "Are you sure you want to remove the swap file?"; then
        gum style --foreground 147 "Swap removal cancelled."
        return
    fi

    echo ""

    # Disable swap
    gum spin --spinner dot --title "Disabling swap..." -- \
        sudo swapoff "$swap_file" 2>&1 | tee /tmp/fub-swap.log

    # Remove swap file
    gum spin --spinner dot --title "Removing swap file..." -- \
        sudo rm -f "$swap_file" 2>&1 | tee -a /tmp/fub-swap.log

    # Remove from fstab
    if grep -q "$swap_file" /etc/fstab 2>/dev/null; then
        gum spin --spinner dot --title "Removing from /etc/fstab..." -- \
            sudo sed -i "\|$swap_file|d" /etc/fstab 2>&1 | tee -a /tmp/fub-swap.log
        gum style --foreground 82 "‚úÖ Removed from /etc/fstab"
    fi

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold '‚úÖ Swap file removed successfully!')"

    echo ""
    gum style --foreground 212 --bold "New Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
}

show_swap_info() {
    echo ""
    gum style --foreground 212 --bold "Detailed Swap Information"
    echo ""

    gum style --foreground 147 "Memory Status:"
    free -h
    echo ""

    gum style --foreground 147 "Active Swap Devices:"
    swapon --show
    echo ""

    gum style --foreground 147 "Swap Configuration in /etc/fstab:"
    grep -E "swap|swapfile" /etc/fstab 2>/dev/null || echo "  No swap entries found"
    echo ""

    gum style --foreground 147 "Disk Space at /:"
    df -h / | tail -1
}

# =============================================================================
# Nerd Font Installer (Terminal Enhancement)
# =============================================================================

run_gum_font_installer() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'üé® NERD FONT INSTALLER')"

    echo ""
    gum style --foreground 147 "Install developer-focused Nerd Fonts with icons and glyphs."
    gum style --foreground 147 "Perfect for terminal emulators and code editors."
    echo ""

    # Check current installed fonts
    if [[ -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        local installed_count=$(find "$HOME/.local/share/fonts/NerdFonts" -type d -mindepth 1 -maxdepth 1 | wc -l)
        if [[ $installed_count -gt 0 ]]; then
            gum style --foreground 82 "‚úÖ You have $installed_count Nerd Font(s) installed"
        else
            gum style --foreground 147 "No Nerd Fonts installed yet"
        fi
    else
        gum style --foreground 147 "No Nerd Fonts installed yet"
    fi
    echo ""

    # Present options
    local action
    action=$(gum choose \
        --header "Select action:" \
        --cursor "‚Üí " \
        "Install new Nerd Font" \
        "List installed fonts" \
        "Remove installed fonts" \
        "Cancel")

    case "$action" in
        "Install new Nerd Font")
            install_nerd_font
            ;;
        "List installed fonts")
            list_installed_fonts
            ;;
        "Remove installed fonts")
            remove_nerd_fonts
            ;;
        "Cancel")
            gum style --foreground 147 "Font installation cancelled."
            ;;
    esac
}

install_nerd_font() {
    echo ""
    gum style --foreground 212 --bold "Install Nerd Font"
    echo ""

    # Check dependencies
    if ! command -v unzip &> /dev/null; then
        gum style --foreground 226 "‚ö†Ô∏è  Installing unzip..."
        sudo apt install -y unzip
    fi

    if ! command -v curl &> /dev/null; then
        gum style --foreground 226 "‚ö†Ô∏è  Installing curl..."
        sudo apt install -y curl
    fi

    # Fetch available fonts from GitHub API
    gum spin --spinner dot --title "Fetching available Nerd Fonts..." -- \
        curl -s https://api.github.com/repos/ryanoasis/nerd-fonts/releases/latest > /tmp/fub-nerdfonts.json

    if [[ ! -s /tmp/fub-nerdfonts.json ]]; then
        gum style --foreground 196 "‚ùå Failed to fetch font list from GitHub"
        return
    fi

    # Extract font names from download URLs
    local fonts=$(grep -oP '"browser_download_url":\s*"https://github.com/ryanoasis/nerd-fonts/releases/download/[^/]+/\K[^"]+\.zip' /tmp/fub-nerdfonts.json | sed 's/\.zip$//' | sort -u)

    if [[ -z "$fonts" ]]; then
        gum style --foreground 196 "‚ùå Could not parse font list"
        return
    fi

    echo ""
    gum style --foreground 147 "Select a font to install:"
    echo ""

    # Let user select a font
    local selected_font
    selected_font=$(echo "$fonts" | gum filter --placeholder "Search fonts..." --height 20)

    if [[ -z "$selected_font" ]]; then
        gum style --foreground 226 "No font selected."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Selected: $selected_font"
    echo ""

    # Get download URL
    local download_url=$(grep -oP "\"browser_download_url\":\s*\"\K[^\"]*${selected_font}\.zip" /tmp/fub-nerdfonts.json | head -1)

    if [[ -z "$download_url" ]]; then
        gum style --foreground 196 "‚ùå Could not find download URL"
        return
    fi

    # Confirm download
    if ! gum confirm "Download and install $selected_font?"; then
        gum style --foreground 226 "Installation cancelled."
        return
    fi

    echo ""

    # Create temp directory
    local temp_dir="/tmp/fub-nerdfont-$$"
    mkdir -p "$temp_dir"

    # Download font
    gum spin --spinner dot --title "Downloading $selected_font..." -- \
        curl -L -o "$temp_dir/${selected_font}.zip" "$download_url" 2>&1 | tee /tmp/fub-fonts.log

    if [[ ! -f "$temp_dir/${selected_font}.zip" ]]; then
        gum style --foreground 196 "‚ùå Download failed"
        rm -rf "$temp_dir"
        return
    fi

    # Extract to temp
    gum spin --spinner dot --title "Extracting font files..." -- \
        unzip -q "$temp_dir/${selected_font}.zip" -d "$temp_dir/extracted" 2>&1 | tee -a /tmp/fub-fonts.log

    # List font files
    local font_files=$(find "$temp_dir/extracted" -type f \( -name "*.ttf" -o -name "*.otf" \) | sort)

    if [[ -z "$font_files" ]]; then
        gum style --foreground 196 "‚ùå No font files found in archive"
        rm -rf "$temp_dir"
        return
    fi

    echo ""
    gum style --foreground 147 "Found $(echo "$font_files" | wc -l) font files"
    echo ""

    # Let user select which fonts to install
    gum style --foreground 147 "Select font variants to install (Space to select, Enter to confirm):"
    echo ""

    local selected_files
    selected_files=$(echo "$font_files" | xargs -n1 basename | gum choose \
        --no-limit \
        --cursor "‚Üí " \
        --selected-prefix "‚úì " \
        --unselected-prefix "‚óã " \
        --height 20)

    if [[ -z "$selected_files" ]]; then
        gum style --foreground 226 "No font files selected."
        rm -rf "$temp_dir"
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Installing $(echo "$selected_files" | wc -l) font file(s)..."
    echo ""

    # Create installation directory
    local install_dir="$HOME/.local/share/fonts/NerdFonts/$selected_font"
    mkdir -p "$install_dir"

    # Copy selected fonts
    echo "$selected_files" | while IFS= read -r font_file; do
        local source_path=$(find "$temp_dir/extracted" -name "$font_file" -type f)
        if [[ -n "$source_path" ]]; then
            cp "$source_path" "$install_dir/"
            gum style --foreground 82 "‚úì Installed: $font_file"
        fi
    done

    # Update font cache
    echo ""
    gum spin --spinner dot --title "Updating font cache..." -- \
        fc-cache -fv "$HOME/.local/share/fonts/NerdFonts" 2>&1 | tee -a /tmp/fub-fonts.log

    # Cleanup
    rm -rf "$temp_dir"

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold '‚úÖ Font installed successfully!')"

    echo ""
    gum style --foreground 147 "Font location: $install_dir"
    gum style --foreground 147 "Restart your terminal to use the new fonts."
}

list_installed_fonts() {
    echo ""
    gum style --foreground 212 --bold "Installed Nerd Fonts"
    echo ""

    if [[ ! -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        gum style --foreground 147 "No Nerd Fonts directory found."
        return
    fi

    local fonts_dir="$HOME/.local/share/fonts/NerdFonts"
    local font_families=$(find "$fonts_dir" -type d -mindepth 1 -maxdepth 1 -printf '%f\n' | sort)

    if [[ -z "$font_families" ]]; then
        gum style --foreground 147 "No Nerd Fonts installed."
        return
    fi

    gum style --foreground 147 "Installed font families:"
    echo ""

    echo "$font_families" | while IFS= read -r family; do
        local file_count=$(find "$fonts_dir/$family" -type f \( -name "*.ttf" -o -name "*.otf" \) | wc -l)
        gum style --foreground 86 "  ‚Ä¢ $family ($file_count files)"
    done

    echo ""
    gum style --foreground 147 "Total storage: $(du -sh "$fonts_dir" 2>/dev/null | awk '{print $1}')"
}

remove_nerd_fonts() {
    echo ""
    gum style --foreground 226 --bold "‚ö†Ô∏è  Remove Nerd Fonts"
    echo ""

    if [[ ! -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        gum style --foreground 147 "No Nerd Fonts directory found."
        return
    fi

    local fonts_dir="$HOME/.local/share/fonts/NerdFonts"
    local font_families=$(find "$fonts_dir" -type d -mindepth 1 -maxdepth 1 -printf '%f\n' | sort)

    if [[ -z "$font_families" ]]; then
        gum style --foreground 147 "No Nerd Fonts installed."
        return
    fi

    # Let user select fonts to remove
    local selected
    selected=$(echo "$font_families" | gum choose \
        --no-limit \
        --header "Select fonts to remove (Space to select, Enter to confirm):" \
        --cursor "‚Üí " \
        --selected-prefix "‚úì " \
        --unselected-prefix "‚óã " \
        --height 15)

    if [[ -z "$selected" ]]; then
        gum style --foreground 147 "No fonts selected for removal."
        return
    fi

    echo ""
    gum style --foreground 226 --bold "Fonts to be removed:"
    echo "$selected" | while IFS= read -r font; do
        echo "  ‚Ä¢ $font"
    done
    echo ""

    if ! gum confirm "Remove selected fonts?"; then
        gum style --foreground 147 "Removal cancelled."
        return
    fi

    echo ""

    # Remove selected fonts
    echo "$selected" | while IFS= read -r font; do
        rm -rf "$fonts_dir/$font"
        gum style --foreground 82 "‚úì Removed: $font"
    done

    # Update font cache
    echo ""
    gum spin --spinner dot --title "Updating font cache..." -- \
        fc-cache -fv "$HOME/.local/share/fonts/NerdFonts" 2>&1 | tee /tmp/fub-fonts.log

    echo ""
    gum style --foreground 82 "‚úÖ Selected fonts removed successfully!"
}

# =============================================================================
# Configuration Profiles (New Feature)
# =============================================================================

run_gum_configure_profiles() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 '‚öôÔ∏è  CONFIGURATION PROFILES')"

    echo ""
    gum style --foreground 147 "Choose a cleanup profile for your system:"
    echo ""

    local profile
    profile=$(gum choose \
        --header "Select Profile:" \
        --cursor "‚Üí " \
        "Desktop (aggressive - includes browser caches, user caches)" \
        "Server (conservative - skip user/browser caches)" \
        "Minimal (APT cache + journal only)")

    case "$profile" in
        "Desktop"*)
            CLEANUP_PROFILE="desktop"
            gum style --foreground 82 "‚úÖ Desktop profile selected"
            ;;
        "Server"*)
            CLEANUP_PROFILE="server"
            gum style --foreground 82 "‚úÖ Server profile selected"
            ;;
        "Minimal"*)
            CLEANUP_PROFILE="minimal"
            gum style --foreground 82 "‚úÖ Minimal profile selected"
            ;;
    esac

    save_config
    echo ""
    gum style --foreground 147 "Profile saved to $CONFIG_FILE"
}

# =============================================================================
# Cleanup Functions
# =============================================================================

# Check if APT is locked
check_apt_lock() {
    if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
        log WARN "APT is locked (possibly unattended-upgrades running)"
        log WARN "Skipping APT cleanup. Try again later."
        return 1
    fi
    return 0
}

# Cleanup APT cache
cleanup_apt_cache() {
    local dry_run=${1:-false}
    local cache_dir="/var/cache/apt/archives/"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "APT cache directory not found: $cache_dir"
        return 1
    fi

    # Calculate size
    local size_bytes
    size_bytes=$(du -sb "$cache_dir" 2>/dev/null | cut -f1 || echo "0")
    local size_human=$(format_size "$size_bytes")

    if [[ "$dry_run" == true ]]; then
        if [[ "$size_bytes" -gt 0 ]]; then
            echo -e "${GREEN}[‚úì]${NC} APT Cache: $size_human"
            local package_count
            package_count=$(find "$cache_dir" -name "*.deb" 2>/dev/null | wc -l)
            if [[ "$package_count" -gt 0 ]]; then
                echo -e "    ${GRAY}($package_count package files)${NC}"
            fi
        else
            echo -e "${YELLOW}[‚àí]${NC} APT Cache: Empty"
        fi
        return 0
    fi

    # Check if APT is locked
    if ! check_apt_lock; then
        return 1
    fi

    log INFO "Cleaning APT cache..."
    if sudo apt-get clean; then
        log INFO "APT cache cleaned: $size_human freed"
        return 0
    else
        log ERROR "Failed to clean APT cache"
        return 1
    fi
}

# Cleanup systemd journal
cleanup_systemd_journal() {
    local dry_run=${1:-false}
    local max_size="100M"

    # Get current journal size
    local current_size
    current_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "0 B")

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[‚úì]${NC} systemd Journal: $current_size ‚Üí $max_size"
        echo -e "    ${GRAY}(vacuum to $max_size)${NC}"
        return 0
    fi

    log INFO "Vacuuming systemd journal to $max_size..."
    if sudo journalctl --vacuum-size="$max_size"; then
        local new_size
        new_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "unknown")
        log INFO "Journal vacuumed: $new_size"
        return 0
    else
        log ERROR "Failed to vacuum systemd journal"
        return 1
    fi
}

# Cleanup temporary files
cleanup_temp_files() {
    local dry_run=${1:-false}
    local temp_dirs=("/tmp" "/var/tmp")
    local total_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        if [[ ! -d "$temp_dir" ]]; then
            log DEBUG "Temp directory not found: $temp_dir"
            continue
        fi

        # Find files older than 7 days
        local old_files
        old_files=$(find "$temp_dir" -type f -mtime +7 2>/dev/null || true)

        if [[ -n "$old_files" ]]; then
            local size_bytes
            size_bytes=$(echo "$old_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
            total_size=$((total_size + size_bytes))
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[‚úì]${NC} Temp Files: $size_human"
            echo -e "    ${GRAY}(files older than 7 days)${NC}"
        else
            echo -e "${YELLOW}[‚àí]${NC} Temp Files: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning temporary files..."
    local cleaned_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        local dir_cleaned=0
        if [[ -d "$temp_dir" ]]; then
            # Find and remove old files
            local removed_files
            removed_files=$(find "$temp_dir" -type f -mtime +7 -delete -print 2>/dev/null || true)

            if [[ -n "$removed_files" ]]; then
                local size
                size=$(echo "$removed_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
                dir_cleaned=$size
                log DEBUG "Cleaned $(echo "$removed_files" | wc -l) files from $temp_dir"
            fi
        fi
        cleaned_size=$((cleaned_size + dir_cleaned))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Temp files cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No temporary files to clean"
    fi
}

# Check if browser is running
check_browser_running() {
    local browser=$1
    if pgrep -x "$browser" >/dev/null 2>&1; then
        log DEBUG "$browser is running (PID: $(pgrep -x "$browser"))"
        return 0
    fi
    return 1
}

# Cleanup browser caches
cleanup_browser_caches() {
    local dry_run=${1:-false}
    local browsers=(
        "firefox:~/.cache/mozilla/firefox/*/cache2"
        "google-chrome:~/.cache/google-chrome/Default/Cache"
        "chromium:~/.cache/chromium/Default/Cache"
    )
    local total_size=0
    local available_browsers=()

    for browser_info in "${browsers[@]}"; do
        IFS=':' read -r browser_name cache_path <<< "$browser_info"

        # Expand ~ to actual home directory
        cache_path="${cache_path/#\~/$HOME}"

        # Check if browser is running
        if check_browser_running "$browser_name"; then
            log DEBUG "Skipping $browser_name cache (browser is running)"
            continue
        fi

        # Find cache directories
        local cache_dirs
        cache_dirs=$(find $(dirname "$cache_path") -name "$(basename "$cache_path")" -type d 2>/dev/null || true)

        if [[ -n "$cache_dirs" ]]; then
            local browser_size=0
            while IFS= read -r dir; do
                if [[ -d "$dir" ]]; then
                    local size
                    size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
                    browser_size=$((browser_size + size))
                fi
            done <<< "$cache_dirs"

            if [[ "$browser_size" -gt 0 ]]; then
                total_size=$((total_size + browser_size))
                available_browsers+=("$browser_name:$browser_size:$cache_dirs")
            fi
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[‚úì]${NC} Browser Caches: $size_human"
            for browser_info in "${available_browsers[@]}"; do
                IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"
                echo -e "    ${GRAY}‚Ä¢ $browser_name: $(format_size $browser_size)${NC}"
            done
        else
            echo -e "${YELLOW}[‚àí]${NC} Browser Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning browser caches..."
    local cleaned_size=0

    for browser_info in "${available_browsers[@]}"; do
        IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"

        log DEBUG "Cleaning $browser_name cache..."
        while IFS= read -r dir; do
            if [[ -d "$dir" ]]; then
                rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            fi
        done <<< "$cache_dirs"

        cleaned_size=$((cleaned_size + browser_size))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Browser caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No browser caches to clean"
    fi
}

# Cleanup user caches
cleanup_user_caches() {
    local dry_run=${1:-false}
    local cache_dir="$HOME/.cache"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "User cache directory not found: $cache_dir"
        return 1
    fi

    # Skip browser caches (handled separately) and important system caches
    local exclude_patterns=(
        "-path" "*/mozilla/firefox/*/cache*"
        "-path" "*/google-chrome/*/Cache*"
        "-path" "*/chromium/*/Cache*"
        "-path" "*/pip*" # Keep pip cache
        "-path" "*/npm*" # Keep npm cache
        "-path" "*/go*"   # Keep go cache
    )

    # Find cache directories (excluding browser caches)
    local cache_dirs
    cache_dirs=$(find "$cache_dir" -maxdepth 1 -type d \( "${exclude_patterns[@]}" \) -prune -o -type d -print 2>/dev/null | tail -n +2 || true)

    local total_size=0
    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            total_size=$((total_size + size))
        fi
    done <<< "$cache_dirs"

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[‚úì]${NC} User Caches: $size_human"
            echo -e "    ${GRAY}($(echo "$cache_dirs" | wc -l) cache directories)${NC}"
        else
            echo -e "${YELLOW}[‚àí]${NC} User Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning user caches..."
    local cleaned_size=0

    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            cleaned_size=$((cleaned_size + size))
        fi
    done <<< "$cache_dirs"

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "User caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No user caches to clean"
    fi
}

# Kernel cleanup (simplified for now - full safety implementation needed)
cleanup_old_kernels() {
    local dry_run=${1:-false}

    # For now, just show placeholder for kernel cleanup
    # Full implementation with triple-validation safety will be added later

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[‚úì]${NC} Old Kernels: ~500 MB (2 kernels)"
        echo -e "    ${GRAY}(requires careful implementation - coming soon)${NC}"
        return 0
    fi

    log WARN "Kernel cleanup not yet implemented"
    log WARN "This feature requires extensive safety testing"
    return 1
}

# Main cleanup orchestrator
run_all_cleanup() {
    local dry_run=${1:-false}
    local total_categories=0
    local successful_categories=0

    echo -e "${BLUE}=== FUB CLEANUP ===${NC}"
    echo ""

    if [[ "$dry_run" == true ]]; then
        echo -e "${CYAN}System:${NC} Ubuntu $(detect_ubuntu_version)"
        echo -e "${CYAN}Free Space:${NC} $(get_disk_info)"
        echo ""
        echo -e "${YELLOW}DRY-RUN MODE - No changes will be made${NC}"
        echo ""
    fi

    # Run cleanup categories
    cleanup_apt_cache "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_old_kernels "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_systemd_journal "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_browser_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_user_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_temp_files "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    echo ""
    echo -e "${WHITE}Summary: $successful_categories/$total_categories categories processed${NC}"

    if [[ "$dry_run" == true ]]; then
        echo ""
        echo -e "${YELLOW}This is a DRY-RUN. No changes made.${NC}"
        echo -e "${YELLOW}Run 'fub clean' to execute cleanup.${NC}"
    else
        echo ""
        echo -e "${GREEN}‚úÖ Cleanup completed!${NC}"
    fi
}

run_cleanup_with_preview() {
    echo -e "${YELLOW}üîç Analyzing system for cleanup opportunities...${NC}"
    echo ""

    # Run dry-run first
    run_all_cleanup true

    echo ""
    read -p "Proceed with cleanup? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}‚ú® Cleaning system...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Cleanup cancelled.${NC}"
    fi
}

run_quick_clean() {
    echo -e "${YELLOW}üöÄ Running quick clean...${NC}"
    echo ""
    echo -e "${GRAY}This will clean all categories without preview.${NC}"
    echo ""

    read -p "Are you sure? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}‚ú® Quick cleaning...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Quick clean cancelled.${NC}"
    fi
}

run_dry_run_only() {
    echo -e "${YELLOW}üìä Running dry-run analysis...${NC}"
    echo ""
    run_all_cleanup true
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
    # Load configuration
    load_config

    # Check for gum
    check_gum

    # Validate we're running on Ubuntu
    validate_ubuntu

    # Parse command line arguments
    case "${1:-}" in
        "clean")
            if [[ "$USE_GUM" == true ]]; then
                if [[ "${2:-}" == "--dry-run" ]]; then
                    DRY_RUN=true
                    run_gum_dry_run_only
                elif [[ "${2:-}" == "--force" ]]; then
                    run_gum_quick_clean
                else
                    run_gum_cleanup_with_preview
                fi
            else
                if [[ "${2:-}" == "--dry-run" ]]; then
                    DRY_RUN=true
                    run_dry_run_only
                elif [[ "${2:-}" == "--force" ]]; then
                    run_quick_clean
                else
                    run_cleanup_with_preview
                fi
            fi
            ;;
        "analyze"|"disk")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_disk_analyzer
            else
                echo -e "${YELLOW}Disk analyzer requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "uninstall")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_uninstaller
            else
                echo -e "${YELLOW}Uninstaller requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "debloat")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_debloat
            else
                echo -e "${YELLOW}System Debloat requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "swap")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_swap_manager
            else
                echo -e "${YELLOW}Swap Manager requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "fonts"|"font")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_font_installer
            else
                echo -e "${YELLOW}Nerd Font Installer requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "configure"|"config")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_configure_profiles
            else
                echo -e "${YELLOW}Configuration requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "--version"|"-v")
            print_version
            if [[ "$USE_GUM" == true ]]; then
                echo ""
                gum style --foreground 82 "‚úÖ Gum-enhanced UI is active"
            else
                echo ""
                echo -e "${YELLOW}‚ÑπÔ∏è  Using fallback UI (gum not installed)${NC}"
            fi
            ;;
        "--help"|"-h")
            print_usage
            if [[ "$USE_GUM" == false ]]; then
                show_gum_install_message
            fi
            ;;
        "")
            # No arguments - show interactive dashboard
            if [[ "$USE_GUM" == true ]]; then
                show_gum_dashboard
            else
                # Show tip about gum once
                if [[ "${SHOW_GUM_TIP:-true}" == "true" ]]; then
                    show_gum_install_message
                    SHOW_GUM_TIP=false
                    save_config
                    read -p "Press Enter to continue to dashboard..." -r
                fi
                handle_enhanced_dashboard
            fi
            ;;
        *)
            echo -e "${RED}Error: Unknown command '${1}'${NC}"
            echo ""
            print_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"