#!/usr/bin/env bash

# FUB - Filesystem Ubuntu Buddy
# Dig deep like a mole to clean your Ubuntu

set -Eeuo pipefail

# Constants
readonly VERSION="1.0.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly INSTALL_DIR="/usr/local/bin"

# Colors for terminal UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;37m'
readonly NC='\033[0m' # No Color

# Global variables
DRY_RUN=false
VERBOSE=false
QUIET=false
USE_GUM=false
CONFIG_DIR="$HOME/.config/fub"
CONFIG_FILE="$CONFIG_DIR/config.conf"

# =============================================================================
# Utility Functions
# =============================================================================

print_usage() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Filesystem Ubuntu Buddy

USAGE:
    $SCRIPT_NAME                    Show interactive dashboard
    $SCRIPT_NAME clean              Clean system with dry-run preview
    $SCRIPT_NAME clean --dry-run    Preview cleanup without execution
    $SCRIPT_NAME clean --force      Clean without confirmation prompts
    $SCRIPT_NAME analyze            Analyze disk usage (requires gum)
    $SCRIPT_NAME uninstall          Uninstall APT/Snap/Flatpak apps (requires gum & fzf)
    $SCRIPT_NAME debloat            Remove bloatware and unnecessary software (requires gum)
    $SCRIPT_NAME swap               Manage swap files for memory (requires gum)
    $SCRIPT_NAME fonts              Install Nerd Fonts for terminal (requires gum)
    $SCRIPT_NAME configure          Configure cleanup profiles (requires gum)
    $SCRIPT_NAME --version          Show version information
    $SCRIPT_NAME --help             Show this help message

EXAMPLES:
    $SCRIPT_NAME                    # Interactive dashboard with navigation
    $SCRIPT_NAME clean --dry-run    # See what would be cleaned
    $SCRIPT_NAME clean              # Execute cleanup safely
    $SCRIPT_NAME analyze            # Browse largest directories
    $SCRIPT_NAME uninstall          # Uninstall APT/Snap/Flatpak packages with fzf
    $SCRIPT_NAME debloat            # Remove snap, bloatware, orphans
    $SCRIPT_NAME swap               # Create/manage swap files
    $SCRIPT_NAME fonts              # Install Nerd Fonts with icons

NEW FEATURES (with gum):
    ğŸ“ Disk Analyzer - Interactively browse and clean large directories
    ğŸ—‘ï¸  App Uninstaller - Unified APT/Snap/Flatpak removal with fzf search
    ğŸ’£ System Debloat - Remove snap packages, GNOME bloatware, orphaned packages
    ğŸ’¾ Swap Manager - Create and manage swap files (2-32GB options)
    ğŸ¨ Nerd Fonts - Install developer fonts with icons and glyphs
    âš™ï¸  Profiles - Configure Desktop, Server, or Minimal cleanup modes
    âœ¨ Enhanced UI - Modern styling with progress indicators

TAGLINE: Dig deep like a mole to clean your Ubuntu

For more information, visit: https://github.com/[user]/fub
Install gum: https://github.com/charmbracelet/gum
EOF
}

print_version() {
    echo "FUB v$VERSION"
    echo "Dig deep like a mole to clean your Ubuntu"
    echo ""
    echo "Platform: Ubuntu $(detect_ubuntu_version)"
    echo "License: MIT"
    echo "Inspired by: https://github.com/tw93/Mole"
}

log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case $level in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  $message" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
        "DEBUG")
            if [[ "$VERBOSE" == true ]]; then
                echo -e "${GRAY}[DEBUG]${NC} $message"
            fi
            ;;
    esac
}

detect_ubuntu_version() {
    if [[ -f /etc/lsb-release ]]; then
        source /etc/lsb-release
        echo "$DISTRIB_RELEASE"
    elif command -v lsb_release >/dev/null 2>&1; then
        lsb_release -rs
    else
        echo "unknown"
    fi
}

validate_ubuntu() {
    local version=$(detect_ubuntu_version)
    log DEBUG "Detected Ubuntu version: $version"

    # Check if we're actually on Ubuntu
    if [[ "$version" == "unknown" ]]; then
        # Check if we're on macOS (for development)
        if [[ "$(uname)" == "Darwin" ]]; then
            log WARN "Running on macOS (development mode)"
            log WARN "Ubuntu validation disabled for development"
            return 0
        fi

        log ERROR "This tool is designed for Ubuntu systems only"
        log ERROR "Detected: $(uname -s) $(uname -r)"
        exit 1
    fi

    case $version in
        24.04|22.04|20.04)
            log INFO "Ubuntu $version detected (supported)"
            return 0
            ;;
        *)
            log WARN "Ubuntu $version not explicitly tested"
            log WARN "Supported versions: 24.04, 22.04, 20.04"
            if [[ "$QUIET" != true ]]; then
                read -p "Continue anyway? [y/N]: " -r confirm
                if [[ ! $confirm =~ ^[Yy]$ ]]; then
                    echo "Aborted."
                    exit 1
                fi
            fi
            ;;
    esac
}

format_size() {
    local bytes=$1
    local units=('B' 'KB' 'MB' 'GB' 'TB')
    local unit=0

    while (( bytes > 1024 && unit < 4 )); do
        bytes=$((bytes / 1024))
        unit=$((unit + 1))
    done

    echo "${bytes}${units[$unit]}"
}

get_disk_info() {
    local free_space
    free_space=$(df -h / | awk 'NR==2 {print $4}')
    local used_percent
    used_percent=$(df -h / | awk 'NR==2 {print $5}')
    echo "$free_space free ($used_percent used)"
}

# =============================================================================
# Gum Detection and Configuration
# =============================================================================

check_gum() {
    if command -v gum >/dev/null 2>&1; then
        USE_GUM=true
        log DEBUG "Gum detected - enhanced UI enabled"
        return 0
    else
        USE_GUM=false
        log DEBUG "Gum not found - using fallback UI"
        return 1
    fi
}

show_gum_install_message() {
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Tip: Install gum for an enhanced UI experience!${NC}"
    echo ""
    echo "  Ubuntu 22.04+ / Debian:"
    echo "    sudo mkdir -p /etc/apt/keyrings"
    echo "    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg"
    echo "    echo 'deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *' | sudo tee /etc/apt/sources.list.d/charm.list"
    echo "    sudo apt update && sudo apt install -y gum"
    echo ""
    echo "  More info: https://github.com/charmbracelet/gum"
    echo ""
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        log DEBUG "Config loaded from $CONFIG_FILE"
    else
        log DEBUG "No config file found at $CONFIG_FILE"
    fi
}

save_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << EOF
# FUB Configuration
# Profile: ${CLEANUP_PROFILE:-default}
CLEANUP_PROFILE="${CLEANUP_PROFILE:-default}"
SHOW_GUM_TIP="${SHOW_GUM_TIP:-true}"
EOF
    log DEBUG "Config saved to $CONFIG_FILE"
}

# =============================================================================
# Enhanced Terminal Navigation Functions (Mole-style)
# =============================================================================

# Terminal control functions
hide_cursor() {
    tput civis 2>/dev/null || echo -ne "\e[?25l"
}

show_cursor() {
    tput cnorm 2>/dev/null || echo -ne "\e[?25h"
}

save_cursor() {
    tput sc 2>/dev/null || echo -ne "\e[s"
}

restore_cursor() {
    tput rc 2>/dev/null || echo -ne "\e[u"
}

clear_line() {
    tput el 2>/dev/null || echo -ne "\e[K"
}

# Enhanced key reading function for arrow key detection
read_key() {
    local key
    local char_count=0
    local max_chars=3  # ESC + [ + letter

    # Set terminal to raw mode for immediate input
    stty -icanon -echo 2>/dev/null || true

    # Read first character with timeout
    IFS= read -r -n1 -s key 2>/dev/null || {
        stty icanon echo 2>/dev/null || true
        return 1
    }

    # Handle escape sequences (arrow keys, function keys)
    if [[ "$key" == $'\e' ]]; then
        # Read remaining characters of escape sequence
        local remaining_chars
        IFS= read -r -n2 -s remaining_chars 2>/dev/null || remaining_chars=""
        key="${key}${remaining_chars}"
    fi

    # Restore terminal settings
    stty icanon echo 2>/dev/null || true

    # Process the key
    case "$key" in
        $'\e[A'|$'\eOA') echo "UP" ;;
        $'\e[B'|$'\eOB') echo "DOWN" ;;
        $'\e[C'|$'\eOC') echo "RIGHT" ;;
        $'\e[D'|$'\eOD') echo "LEFT" ;;
        $'\e') echo "ESC" ;;
        '') echo "ENTER" ;;
        $'\n'|$'\r') echo "ENTER" ;;
        'q'|'Q') echo "QUIT" ;;
        'j'|'J') echo "DOWN" ;;
        'k'|'K') echo "UP" ;;
        'h'|'H') echo "LEFT" ;;
        'l'|'L') echo "RIGHT" ;;
        *) echo "UNKNOWN" ;;
    esac
}

# Calculate adaptive border width
calculate_border_width() {
    local terminal_width=$(tput cols 2>/dev/null || echo 80)
    local min_width=40
    local max_width=120

    # Use smaller of terminal width or max width
    local effective_width=$(( terminal_width < max_width ? terminal_width : max_width ))

    # Ensure minimum width
    if [[ $effective_width -lt $min_width ]]; then
        effective_width=$min_width
    fi

    echo $effective_width
}

# Test Unicode box drawing support
test_unicode_support() {
    printf "â•”â•â•—" >/dev/null 2>&1 && return 0 || return 1
}

# Terminal capability detection (enhanced)
detect_terminal_capabilities() {
    local has_colors=false
    local has_cursor_control=false
    local has_unicode=false
    local has_box_drawing=false

    # Check color support
    if command -v tput >/dev/null 2>&1 && [[ $(tput colors 2>/dev/null) -gt 8 ]]; then
        has_colors=true
    fi

    # Check cursor control
    if command -v tput >/dev/null 2>&1; then
        has_cursor_control=true
    fi

    # Check Unicode support
    if [[ -n "${LANG:-}" && "${LANG}" == *"UTF"* ]]; then
        has_unicode=true
    fi

    # Test box drawing characters
    if test_unicode_support; then
        has_box_drawing=true
    fi

    # Set global capability flags
    TERMINAL_HAS_COLORS=$has_colors
    TERMINAL_HAS_CURSOR=$has_cursor_control
    TERMINAL_HAS_UNICODE=$has_unicode
    TERMINAL_HAS_BOX_DRAWING=$has_box_drawing

    return 0
}

# Select appropriate border style based on terminal capabilities
select_border_style() {
    if [[ "$TERMINAL_HAS_BOX_DRAWING" == true ]]; then
        echo "double"    # â•”â•â•—â•‘â•šâ•
    elif [[ "$TERMINAL_HAS_UNICODE" == true ]]; then
        echo "single"    # â””â”€â”˜â”‚â”Œâ”
    else
        echo "ascii"     # +-++|
    fi
}

# Generate border characters dynamically
generate_border() {
    local width=$1
    local style=$2
    local line_type=${3:-"all"}

    case "$style" in
        "double")
            case "$line_type" in
                "top")
                    local top_line="â•”"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="â•"
                    done
                    top_line+="â•—"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="â•š"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="â•"
                    done
                    bottom_line+="â•"
                    echo "$bottom_line"
                    ;;
                "side") echo "â•‘" ;;
                "all")
                    local top_line="â•”"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="â•"
                    done
                    top_line+="â•—"
                    echo "$top_line"
                    echo "â•‘"
                    local bottom_line="â•š"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="â•"
                    done
                    bottom_line+="â•"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
        "single")
            case "$line_type" in
                "top")
                    local top_line="â”Œ"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="â”€"
                    done
                    top_line+="â”"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="â””"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="â”€"
                    done
                    bottom_line+="â”˜"
                    echo "$bottom_line"
                    ;;
                "side") echo "â”‚" ;;
                "all")
                    local top_line="â”Œ"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="â”€"
                    done
                    top_line+="â”"
                    echo "$top_line"
                    echo "â”‚"
                    local bottom_line="â””"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="â”€"
                    done
                    bottom_line+="â”˜"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
        "ascii")
            case "$line_type" in
                "top")
                    local top_line="+"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="-"
                    done
                    top_line+="+"
                    echo "$top_line"
                    ;;
                "bottom")
                    local bottom_line="+"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="-"
                    done
                    bottom_line+="+"
                    echo "$bottom_line"
                    ;;
                "side") echo "|" ;;
                "all")
                    local top_line="+"
                    for ((i=0; i<width-2; i++)); do
                        top_line+="-"
                    done
                    top_line+="+"
                    echo "$top_line"
                    echo "|"
                    local bottom_line="+"
                    for ((i=0; i<width-2; i++)); do
                        bottom_line+="-"
                    done
                    bottom_line+="+"
                    echo "$bottom_line"
                    ;;
            esac
            ;;
    esac
}

# Cleanup terminal state
cleanup_terminal() {
    show_cursor
    stty icanon echo 2>/dev/null || true
    clear
}

# Set up cleanup on exit
trap cleanup_terminal EXIT

# =============================================================================
# Enhanced Interactive Dashboard UI (Mole-style)
# =============================================================================

show_enhanced_dashboard() {
    local current_selection=${1:-1}
    local terminal_height
    local border_width

    # Detect terminal capabilities first
    detect_terminal_capabilities

    # Calculate adaptive dimensions
    terminal_height=$(tput lines 2>/dev/null || echo 24)
    border_width=$(calculate_border_width)

    # Select border style based on capabilities
    local border_style=$(select_border_style)

    # Clear screen and hide cursor
    clear
    hide_cursor

    # Calculate centering for better UX
    local title_line=$((terminal_height / 8))

    # Move cursor to title position
    tput cup "$title_line" 0 2>/dev/null || echo -ne "\e[${title_line};1H"

    # Generate borders dynamically
    local top_border=$(generate_border $border_width $border_style "top")
    local side_char=$(generate_border $border_width $border_style "side")
    local bottom_border=$(generate_border $border_width $border_style "bottom")

    # Center the title
    local title="FUB DASHBOARD"
    local title_len=${#title}
    local title_col=$(( (border_width - title_len) / 2 ))
    local tagline="Dig deep like a mole to clean your Ubuntu"
    local tagline_len=${#tagline}
    local tagline_col=$(( (border_width - tagline_len) / 2 ))

    # Display title box with safe color handling
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        printf "${BLUE}%s${NC}\n" "$top_border"
        printf "${BLUE}%s${NC}%*s${WHITE}%s${NC}%*s${BLUE}%s${NC}\n" \
            "$side_char" $title_col "" "$title" $((border_width - title_col - title_len)) "" "$side_char"
        printf "${BLUE}%s${NC}%*s${CYAN}%s${NC}%*s${BLUE}%s${NC}\n" \
            "$side_char" $tagline_col "" "$tagline" $((border_width - tagline_col - tagline_len)) "" "$side_char"
        printf "${BLUE}%s${NC}\n" "$bottom_border"
    else
        printf "%s\n" "$top_border"
        printf "%s%*s%s%*s%s\n" \
            "$side_char" $title_col "" "$title" $((border_width - title_col - title_len)) "" "$side_char"
        printf "%s%*s%s%*s%s\n" \
            "$side_char" $tagline_col "" "$tagline" $((border_width - tagline_col - tagline_len)) "" "$side_char"
        printf "%s\n" "$bottom_border"
    fi
    echo ""

    # System info
    local ubuntu_version=$(detect_ubuntu_version)
    local disk_info=$(get_disk_info)
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        printf "${CYAN}System Info: %s | %s${NC}\n" "Ubuntu $ubuntu_version" "$disk_info"
    else
        printf "System Info: %s | %s\n" "Ubuntu $ubuntu_version" "$disk_info"
    fi
    echo ""

    # Menu options with dynamic highlighting
    local options=(
        "ğŸ§¹  Clean System (with dry-run preview)"
        "ğŸš€  Quick Clean (skip preview)"
        "ğŸ“Š  Dry-Run Only (analyze what can be cleaned)"
        "âš™ï¸  System Status"
        "â“  Help & Documentation"
        "ğŸšª  Exit"
    )

    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        echo -e "${WHITE}Main Menu:${NC}"
    else
        echo "Main Menu:"
    fi
    echo ""

    # Calculate max text width for consistent formatting
    local max_text_length=0
    for option in "${options[@]}"; do
        local option_len=${#option}
        if [[ $option_len -gt $max_text_length ]]; then
            max_text_length=$option_len
        fi
    done

    # Ensure minimum width for menu items
    local menu_width=$((max_text_length > 46 ? max_text_length : 46))
    if [[ $menu_width -gt $((border_width - 4)) ]]; then
        menu_width=$((border_width - 4))
    fi

    # Display options with highlighting
    for i in "${!options[@]}"; do
        local option_text="${options[$i]}"

        if [[ $((i + 1)) -eq $current_selection ]]; then
            # Bold cyan selection (without numbers)
            if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
                printf "  \e[1m\e[36m%-${menu_width}s\e[0m\n" "$option_text"
            else
                printf "  %-${menu_width}s\n" "$option_text"
            fi
        else
            # Normal display with appropriate color
            if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
                printf "  \e[37m%-${menu_width}s\e[0m\n" "$option_text"
            else
                printf "  %-${menu_width}s\n" "$option_text"
            fi
        fi
    done

    echo ""
    if [[ "$TERMINAL_HAS_COLORS" == true ]]; then
        echo -e "${YELLOW}Navigation: â†‘â†“ arrows to move, Enter to select, q to quit${NC}"
    else
        echo "Navigation: â†‘â†“ arrows to move, Enter to select, q to quit"
    fi
    echo ""
}

# Handle terminal resize events
handle_terminal_resize() {
    # Redraw dashboard with current selection (new width calculation)
    show_enhanced_dashboard "$current_selection"
}

# Set up resize handler
trap 'handle_terminal_resize' WINCH

# Enhanced dashboard handler with arrow key navigation
handle_enhanced_dashboard() {
    local current_selection=1
    local max_selection=6
    local key_pressed

    # Detect terminal capabilities
    detect_terminal_capabilities

    while true; do
        show_enhanced_dashboard "$current_selection"

        # Read user input
        key_pressed=$(read_key) || continue

        case "$key_pressed" in
            "UP"|"k")
                ((current_selection > 1)) && ((current_selection--))
                ;;
            "DOWN"|"j")
                ((current_selection < max_selection)) && ((current_selection++))
                ;;
            "ENTER")
                show_cursor  # Restore cursor before executing action
                execute_dashboard_option "$current_selection"
                hide_cursor  # Hide cursor again for next display
                ;;
            "ESC"|"QUIT")
                show_cursor
                echo -e "${GREEN}Goodbye! ğŸ‘‹${NC}"
                exit 0
                ;;
            "UNKNOWN")
                # Ignore unknown keys
                ;;
        esac
    done
}

# Execute selected dashboard option
execute_dashboard_option() {
    local selection=$1

    case $selection in
        1)
            clear
            echo -e "${GREEN}Selected: Clean System with preview${NC}"
            sleep 1
            run_cleanup_with_preview
            ;;
        2)
            clear
            echo -e "${GREEN}Selected: Quick Clean${NC}"
            sleep 1
            run_quick_clean
            ;;
        3)
            clear
            echo -e "${GREEN}Selected: Dry-Run Only${NC}"
            sleep 1
            run_dry_run_only
            ;;
        4)
            clear
            echo -e "${GREEN}Selected: System Status${NC}"
            sleep 1
            show_system_status
            ;;
        5)
            clear
            echo -e "${GREEN}Selected: Help & Documentation${NC}"
            sleep 1
            show_help_screen
            ;;
        6)
            echo -e "${GREEN}Goodbye! ğŸ‘‹${NC}"
            exit 0
            ;;
    esac

    # Return to main menu prompt
    if [[ "$selection" != "6" ]]; then
        echo ""
        read -p "Press Enter to return to main menu..." -r
    fi
}

show_system_status() {
    clear
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}                     ${WHITE}SYSTEM STATUS${NC}                        ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    echo -e "${CYAN}System Information:${NC}"
    echo "  Ubuntu Version: $(detect_ubuntu_version)"
    echo "  Kernel: $(uname -r)"
    echo "  Architecture: $(uname -m)"
    echo "  Uptime: $(uptime -p 2>/dev/null || echo "N/A")"
    echo ""

    echo -e "${CYAN}Disk Usage:${NC}"
    df -h | grep -E '^/dev/' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}Memory Usage:${NC}"
    free -h | grep -E '^Mem:|^Swap:' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}FUB Status:${NC}"
    echo "  Version: $VERSION"
    echo "  Installation: $(if [[ -x "$INSTALL_DIR/fub" ]]; then echo "âœ… Installed"; else echo "âŒ Not found in $INSTALL_DIR"; fi)"
    echo ""
}

show_help_screen() {
    clear
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}                        ${WHITE}HELP & DOCS${NC}                        ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    echo -e "${WHITE}What is FUB?${NC}"
    echo "FUB (Filesystem Ubuntu Buddy) is a terminal-based cleanup utility"
    echo "for Ubuntu, inspired by Mole for macOS. It helps you reclaim disk"
    echo "space by cleaning system caches, old kernels, and temporary files."
    echo ""

    echo -e "${WHITE}Cleanup Categories:${NC}"
    echo "  ğŸ§¹ APT Cache - Old package files"
    echo "  ğŸ—‚ï¸  Old Kernels - Previous kernel versions (keeps current + 1)"
    echo "  ğŸ“‹ systemd Journal - System logs"
    echo "  ğŸŒ Browser Caches - Firefox, Chrome, Chromium"
    echo "  ğŸ’¾ User Caches - Application caches in ~/.cache/"
    echo "  ğŸ—‘ï¸  Temp Files - Old temporary files"
    echo ""

    echo -e "${WHITE}Safety Features:${NC}"
    echo "  âœ… Never removes current kernel"
    echo "  âœ… Dry-run mode shows exactly what will be cleaned"
    echo "  âœ… Explicit confirmations for all operations"
    echo "  âœ… Skips cleanup if APT is locked"
    echo ""

    echo -e "${WHITE}Command Line Usage:${NC}"
    echo "  fub                    Show this interactive dashboard"
    echo "  fub clean --dry-run    Preview cleanup without execution"
    echo "  fub clean              Execute cleanup safely"
    echo "  fub --help             Show help message"
    echo "  fub --version          Show version information"
    echo ""

    echo -e "${WHITE}More Information:${NC}"
    echo "  GitHub: https://github.com/[user]/fub"
    echo "  Inspired by: https://github.com/tw93/Mole"
    echo ""
}

# =============================================================================
# Gum-Enhanced Dashboard (Modern TUI)
# =============================================================================

show_gum_dashboard() {
    clear

    # ASCII Art Header inspired by Mole
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"

    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                                                                           â•‘"

    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                    ğŸ¹  FUB - Filesystem Ubuntu Buddy                     â•‘"

    gum style \
        --foreground 147 \
        --align center \
        --width 80 \
        "â•‘                   Dig deep like a mole to clean Ubuntu                   â•‘"

    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                                                                           â•‘"

    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""

    # System Information Panel
    local ubuntu_ver=$(detect_ubuntu_version)
    local kernel_ver=$(uname -r)
    local disk_info=$(get_disk_info)
    local hostname=$(hostname)
    local uptime_info=$(uptime -p 2>/dev/null | sed 's/up //' || echo "N/A")

    gum style \
        --border rounded \
        --border-foreground 86 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 86 --bold '  System Information')" \
        "" \
        "$(gum style --foreground 147 "  ğŸ’» Host      : $hostname")" \
        "$(gum style --foreground 147 "  ğŸ§ OS        : Ubuntu $ubuntu_ver")" \
        "$(gum style --foreground 147 "  âš™ï¸  Kernel    : $kernel_ver")" \
        "$(gum style --foreground 147 "  ğŸ’¾ Disk      : $disk_info")" \
        "$(gum style --foreground 147 "  â±ï¸  Uptime    : $uptime_info")"

    echo ""

    # Main Menu Header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  MAIN MENU  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"

    echo ""

    # Interactive menu with enhanced styling
    local choice
    choice=$(gum choose \
        --cursor "â–¶ " \
        --cursor-prefix "  " \
        --selected-prefix "  " \
        --height 15 \
        --header "" \
        "  ğŸ§¹  Clean System          Deep cleanup with preview before execution" \
        "  ğŸš€  Quick Clean           Fast cleanup without preview (dry-run first)" \
        "  ğŸ“Š  Analyze Only          Calculate cleanup size without changes" \
        "" \
        "  ğŸ“  Disk Analyzer         Browse and analyze disk usage by directory" \
        "  ğŸ—‘ï¸  Uninstall Apps        Remove APT/Snap/Flatpak packages with fzf" \
        "  ğŸ’£  System Debloat        Remove bloatware and unnecessary packages" \
        "" \
        "  ğŸ’¾  Swap Manager          Create or manage swap files (2-32GB)" \
        "  ğŸ¨  Nerd Fonts            Install developer fonts with icons" \
        "  âš™ï¸  Configure             Setup cleanup profiles and preferences" \
        "" \
        "  â„¹ï¸  System Status         View detailed system information" \
        "  â“  Help                  Show documentation and usage guide" \
        "  ğŸšª  Exit                  Quit FUB")

    echo ""
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
    echo ""

    # Handle empty selection (separator lines)
    if [[ -z "$choice" ]]; then
        show_gum_dashboard
        return
    fi

    case "$choice" in
        *"Clean System"*) run_gum_cleanup_with_preview ;;
        *"Quick Clean"*) run_gum_quick_clean ;;
        *"Analyze Only"*) run_gum_dry_run_only ;;
        *"Disk Analyzer"*) run_gum_disk_analyzer ;;
        *"Uninstall Apps"*) run_gum_uninstaller ;;
        *"System Debloat"*) run_gum_debloat ;;
        *"Swap Manager"*) run_gum_swap_manager ;;
        *"Nerd Fonts"*) run_gum_font_installer ;;
        *"Configure"*) run_gum_configure_profiles ;;
        *"System Status"*) show_gum_system_status ;;
        *"Help"*) show_gum_help_screen ;;
        *"Exit"*)
            clear
            gum style \
                --foreground 212 \
                --bold \
                --align center \
                "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            gum style \
                --foreground 147 \
                --align center \
                "â•‘                                               â•‘"
            gum style \
                --foreground 86 \
                --align center \
                "â•‘      Thank you for using FUB! ğŸ¹ ğŸ‘‹          â•‘"
            gum style \
                --foreground 147 \
                --align center \
                "â•‘     Your Ubuntu is now cleaner and faster    â•‘"
            gum style \
                --foreground 147 \
                --align center \
                "â•‘                                               â•‘"
            gum style \
                --foreground 212 \
                --bold \
                --align center \
                "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            exit 0
            ;;
        *)
            show_gum_dashboard
            return
            ;;
    esac

    # Return to menu with styled prompt
    echo ""
    echo ""
    gum style \
        --foreground 86 \
        --align center \
        "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    gum style \
        --foreground 147 \
        --align center \
        "Press Enter to return to main menu..."
    read -r
    show_gum_dashboard
}

show_gum_system_status() {
    clear

    # Header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                          â„¹ï¸  SYSTEM STATUS                                â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""

    # System Information
    local ubuntu_ver=$(detect_ubuntu_version)
    local kernel_ver=$(uname -r)
    local arch=$(uname -m)
    local uptime_info=$(uptime -p 2>/dev/null | sed 's/up //' || echo "N/A")
    local hostname=$(hostname)
    local user=$(whoami)

    gum style \
        --border rounded \
        --border-foreground 86 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 86 --bold 'â–¶ System Information')" \
        "" \
        "$(gum style --foreground 147 "  ğŸ’» Hostname    : $hostname")" \
        "$(gum style --foreground 147 "  ğŸ‘¤ User        : $user")" \
        "$(gum style --foreground 147 "  ğŸ§ OS          : Ubuntu $ubuntu_ver")" \
        "$(gum style --foreground 147 "  âš™ï¸  Kernel      : $kernel_ver")" \
        "$(gum style --foreground 147 "  ğŸ—ï¸  Architecture: $arch")" \
        "$(gum style --foreground 147 "  â±ï¸  Uptime      : $uptime_info")"

    echo ""

    # Disk Usage
    gum style \
        --border rounded \
        --border-foreground 212 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 212 --bold 'â–¶ Disk Usage')" \
        ""

    df -h | grep -E '^/dev/' | while IFS= read -r line; do
        local dev=$(echo "$line" | awk '{print $1}')
        local size=$(echo "$line" | awk '{print $2}')
        local used=$(echo "$line" | awk '{print $3}')
        local avail=$(echo "$line" | awk '{print $4}')
        local percent=$(echo "$line" | awk '{print $5}')
        local mount=$(echo "$line" | awk '{print $6}')

        echo "  ğŸ“Š $mount"
        echo "     Size: $size | Used: $used | Available: $avail | Usage: $percent"
        echo ""
    done

    # Memory Usage
    gum style \
        --border rounded \
        --border-foreground 117 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 117 --bold 'â–¶ Memory Usage')" \
        ""

    local mem_total=$(free -h | awk '/^Mem:/ {print $2}')
    local mem_used=$(free -h | awk '/^Mem:/ {print $3}')
    local mem_free=$(free -h | awk '/^Mem:/ {print $4}')
    local mem_percent=$(free | awk '/^Mem:/ {printf "%.1f%%", ($3/$2)*100}')

    local swap_total=$(free -h | awk '/^Swap:/ {print $2}')
    local swap_used=$(free -h | awk '/^Swap:/ {print $3}')
    local swap_free=$(free -h | awk '/^Swap:/ {print $4}')

    echo "  ğŸ’¾ RAM"
    echo "     Total: $mem_total | Used: $mem_used | Free: $mem_free | Usage: $mem_percent"
    echo ""
    echo "  ğŸ’¿ Swap"
    echo "     Total: $swap_total | Used: $swap_used | Free: $swap_free"

    echo ""

    # FUB Status
    gum style \
        --border rounded \
        --border-foreground 226 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 226 --bold 'â–¶ FUB Status')" \
        "" \
        "$(gum style --foreground 147 "  ğŸ“¦ Version     : $VERSION")" \
        "$(gum style --foreground 147 "  ğŸ¨ Gum         : $(if command -v gum >/dev/null 2>&1; then echo "âœ… Installed ($(gum --version 2>/dev/null | head -1 || echo 'unknown'))"; else echo "âŒ Not installed"; fi)")" \
        "$(gum style --foreground 147 "  ğŸ” Fzf         : $(if command -v fzf >/dev/null 2>&1; then echo "âœ… Installed ($(fzf --version 2>/dev/null | awk '{print $1}' || echo 'unknown'))"; else echo "âŒ Not installed"; fi)")" \
        "$(gum style --foreground 147 "  ğŸ› ï¸  Install Path: $INSTALL_DIR/fub $(if [[ -x "$INSTALL_DIR/fub" ]]; then echo "âœ…"; else echo "âŒ"; fi)")"

    echo ""
}

show_gum_help_screen() {
    clear

    # Header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                      â“  HELP & DOCUMENTATION                             â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""

    # What is FUB?
    gum style \
        --border rounded \
        --border-foreground 86 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 86 --bold 'â–¶ What is FUB?')" \
        "" \
        "$(gum style --foreground 147 "  FUB (Filesystem Ubuntu Buddy) is a powerful terminal-based cleanup")" \
        "$(gum style --foreground 147 "  utility for Ubuntu, inspired by Mole for macOS. It helps you reclaim")" \
        "$(gum style --foreground 147 "  disk space by deep cleaning system caches, old kernels, logs, and")" \
        "$(gum style --foreground 147 "  temporary files with a beautiful interactive interface.")"

    echo ""

    # Cleanup Categories
    gum style \
        --border rounded \
        --border-foreground 212 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 212 --bold 'â–¶ Cleanup Categories')" \
        "" \
        "$(gum style --foreground 147 "  ğŸ§¹ APT Cache       : Old package files from /var/cache/apt/")" \
        "$(gum style --foreground 147 "  ğŸ—‚ï¸  Old Kernels     : Previous kernel versions (keeps current + 1)")" \
        "$(gum style --foreground 147 "  ğŸ“‹ systemd Journal : System logs (vacuum to configurable size)")" \
        "$(gum style --foreground 147 "  ğŸŒ Browser Caches  : Firefox, Chrome, Chromium, Edge cache files")" \
        "$(gum style --foreground 147 "  ğŸ’¾ User Caches     : Application caches in ~/.cache/ directory")" \
        "$(gum style --foreground 147 "  ğŸ—‘ï¸  Temp Files      : Old temporary files from /tmp and /var/tmp")"

    echo ""

    # New Features
    gum style \
        --border rounded \
        --border-foreground 117 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 117 --bold 'â–¶ Enhanced Features (with gum)')" \
        "" \
        "$(gum style --foreground 147 "  ğŸ“ Disk Analyzer   : Interactively browse and analyze disk usage")" \
        "$(gum style --foreground 147 "  ğŸ—‘ï¸  App Uninstaller : Search and remove APT/Snap/Flatpak packages")" \
        "$(gum style --foreground 147 "  ğŸ’£ System Debloat  : Remove bloatware and unnecessary software")" \
        "$(gum style --foreground 147 "  ğŸ’¾ Swap Manager    : Create and manage swap files (2-32GB)")" \
        "$(gum style --foreground 147 "  ğŸ¨ Nerd Fonts      : Install developer fonts with icons")" \
        "$(gum style --foreground 147 "  âš™ï¸  Profiles        : Desktop, Server, or Minimal cleanup modes")"

    echo ""

    # Safety Features
    gum style \
        --border rounded \
        --border-foreground 226 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 226 --bold 'â–¶ Safety Features')" \
        "" \
        "$(gum style --foreground 82 "  âœ… Never removes current kernel")" \
        "$(gum style --foreground 82 "  âœ… Dry-run mode shows exactly what will be cleaned")" \
        "$(gum style --foreground 82 "  âœ… Explicit confirmations for all operations")" \
        "$(gum style --foreground 82 "  âœ… Skips cleanup if APT is locked")" \
        "$(gum style --foreground 82 "  âœ… Checks if browsers are running before cleaning caches")" \
        "$(gum style --foreground 82 "  âœ… Comprehensive logging of all operations")"

    echo ""

    # Quick Commands
    gum style \
        --border rounded \
        --border-foreground 147 \
        --padding "0 2" \
        --width 78 \
        --margin "0 1" \
        "$(gum style --foreground 147 --bold 'â–¶ Quick Commands')" \
        "" \
        "$(gum style --foreground 86 "  fub                : Launch interactive dashboard")" \
        "$(gum style --foreground 86 "  fub clean          : Deep clean with preview")" \
        "$(gum style --foreground 86 "  fub clean --dry-run: Preview cleanup without changes")" \
        "$(gum style --foreground 86 "  fub uninstall      : Uninstall apps with fzf search")" \
        "$(gum style --foreground 86 "  fub analyze        : Browse disk usage")" \
        "$(gum style --foreground 86 "  fub --help         : Show detailed help")"

    echo ""
}

# =============================================================================
# Gum-Enhanced Cleanup Functions
# =============================================================================

run_gum_cleanup_with_preview() {
    clear

    # Clean header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                        SYSTEM CLEANUP WITH PREVIEW                       â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""
    gum style --foreground 147 "Analyzing system for cleanup opportunities..."
    echo ""

    # Run dry-run first
    run_all_cleanup true

    echo ""
    if gum confirm "Proceed with cleanup?"; then
        echo ""
        gum spin --spinner dot --title "Preparing cleanup..." -- sleep 1
        echo ""
        run_gum_cleanup_execute
    else
        gum style --foreground 226 "Cleanup cancelled."
    fi
}

run_gum_quick_clean() {
    clear

    # Clean header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                           QUICK CLEAN MODE                               â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""
    gum style --foreground 244 "This will clean all categories without preview."
    echo ""

    if gum confirm "Are you sure?"; then
        echo ""
        run_gum_cleanup_execute
    else
        gum style --foreground 226 "Quick clean cancelled."
    fi
}

run_gum_dry_run_only() {
    clear

    # Clean header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                          DRY-RUN ANALYSIS                                â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""
    run_all_cleanup true
}

run_gum_cleanup_execute() {
    # Cleanup with spinners for each category
    gum spin --spinner dot --title "Cleaning APT cache..." -- bash -c "cleanup_apt_cache false" 2>/dev/null || true
    gum spin --spinner dot --title "Vacuuming systemd journal..." -- bash -c "cleanup_systemd_journal false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning browser caches..." -- bash -c "cleanup_browser_caches false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning user caches..." -- bash -c "cleanup_user_caches false" 2>/dev/null || true
    gum spin --spinner dot --title "Cleaning temp files..." -- bash -c "cleanup_temp_files false" 2>/dev/null || true

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold '[SUCCESS] Cleanup completed successfully')"
}

# =============================================================================
# Disk Analyzer (New Mole-Inspired Feature)
# =============================================================================

run_gum_disk_analyzer() {
    clear

    # Clean header
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                            DISK ANALYZER                                 â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""
    gum style --foreground 147 "Analyzing disk usage... This may take a moment."
    echo ""

    # Get largest directories in home
    local temp_file=$(mktemp)
    du -h "$HOME" 2>/dev/null | sort -hr | head -30 > "$temp_file"

    # Let user select directory to explore
    local selected
    selected=$(cat "$temp_file" | gum filter --placeholder "Search directories..." --height 20)

    rm -f "$temp_file"

    if [[ -n "$selected" ]]; then
        local dir_path=$(echo "$selected" | awk '{print $2}')
        local dir_size=$(echo "$selected" | awk '{print $1}')

        echo ""
        gum style --foreground 212 --bold "Selected: $dir_path ($dir_size)"
        echo ""

        # Show directory contents
        ls -lh "$dir_path" 2>/dev/null | tail -n +2 | head -20

        echo ""
        if gum confirm "Open this directory in your file manager?"; then
            xdg-open "$dir_path" 2>/dev/null || true
        fi
    fi
}

# =============================================================================
# App Uninstaller (New Mole-Inspired Feature)
# =============================================================================

run_gum_uninstaller() {
    clear

    # Clean header without complex emojis
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•‘                      APP UNINSTALLER - APT + Snap + Flatpak             â•‘"
    gum style \
        --foreground 212 \
        --bold \
        --align center \
        --width 80 \
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    echo ""

    # Temp files for different package types
    local temp_apt=$(mktemp)
    local temp_snap=$(mktemp)
    local temp_flatpak=$(mktemp)
    local formatted_list=$(mktemp)
    local formatted_user=$(mktemp)
    local formatted_system=$(mktemp)
    local current_time=$(date +%s)

    # Scan APT packages
    gum spin --spinner dot --title "Scanning APT packages..." -- bash -c "
        dpkg-query -W -f='\${Package}|\${Installed-Size}|apt\n' 2>/dev/null | \
        grep -v '^|' | \
        sort -t'|' -k2 -n -r > '$temp_apt'
    "
    local apt_count=$(wc -l < "$temp_apt" 2>/dev/null || echo "0")

    # Scan Snap packages (if installed)
    local snap_count=0
    if command -v snap &> /dev/null; then
        gum spin --spinner dot --title "Scanning Snap packages..." -- bash -c "
            snap list 2>/dev/null | tail -n +2 | awk '{
                name=\$1
                # Get snap size in bytes, convert to KB
                cmd=\"du -sk /snap/\" name \" 2>/dev/null | awk '{print \$1}'\"
                cmd | getline size_kb
                close(cmd)
                if (size_kb == \"\") size_kb = \"0\"
                print name \"|\" size_kb \"|snap\"
            }' | sort -t'|' -k2 -n -r > '$temp_snap'
        " 2>/dev/null || touch "$temp_snap"
        snap_count=$(wc -l < "$temp_snap" 2>/dev/null || echo "0")
    fi

    # Scan Flatpak packages (if installed)
    local flatpak_count=0
    if command -v flatpak &> /dev/null; then
        gum spin --spinner dot --title "Scanning Flatpak packages..." -- bash -c "
            flatpak list --app 2>/dev/null | awk -F'\t' '{
                name=\$2
                app_id=\$1
                # Get flatpak size
                cmd=\"flatpak info --show-size \" app_id \" 2>/dev/null | grep -i 'installed size' | awk '{print \$3}'\"
                cmd | getline size_str
                close(cmd)
                # Convert size to KB (handle MB, GB, KB suffixes)
                if (size_str ~ /GB/) {
                    gsub(/GB/, \"\", size_str)
                    size_kb = size_str * 1048576
                } else if (size_str ~ /MB/) {
                    gsub(/MB/, \"\", size_str)
                    size_kb = size_str * 1024
                } else if (size_str ~ /kB/) {
                    gsub(/kB/, \"\", size_str)
                    size_kb = size_str
                } else {
                    size_kb = 0
                }
                print app_id \"|\" int(size_kb) \"|flatpak\"
            }' | sort -t'|' -k2 -n -r > '$temp_flatpak'
        " 2>/dev/null || touch "$temp_flatpak"
        flatpak_count=$(wc -l < "$temp_flatpak" 2>/dev/null || echo "0")
    fi

    local total_packages=$((apt_count + snap_count + flatpak_count))
    echo ""
    gum style --foreground 82 "Found: $apt_count APT + $snap_count Snap + $flatpak_count Flatpak = $total_packages total packages"
    echo ""

    # Format packages with human-readable sizes, age indicators, and categories
    # Process all package types: APT, Snap, Flatpak
    for pkg_file in "$temp_apt" "$temp_snap" "$temp_flatpak"; do
        [[ ! -s "$pkg_file" ]] && continue

        while IFS='|' read -r pkg size_kb pkg_type; do
            if [[ -n "$pkg" && -n "$size_kb" && -n "$pkg_type" ]]; then
                # Convert KB to human readable
                if [[ $size_kb -gt 1048576 ]]; then
                    size_display=$(awk "BEGIN {printf \"%.1fG\", $size_kb/1048576}")
                elif [[ $size_kb -gt 1024 ]]; then
                    size_display=$(awk "BEGIN {printf \"%.0fM\", $size_kb/1024}")
                else
                    size_display="${size_kb}K"
                fi

                # Package type indicator
                local type_color="147"
                case "$pkg_type" in
                    snap)
                        type_color="214"
                        ;;
                    flatpak)
                        type_color="117"
                        ;;
                esac

                # Determine package age (for APT only, others default to recent)
                local age_indicator="new"
                local age_color="82"  # Green

                if [[ "$pkg_type" == "apt" ]]; then
                    local list_file="/var/lib/dpkg/info/${pkg}.list"
                    if [[ -f "$list_file" ]]; then
                        local file_time=$(stat -c %Y "$list_file" 2>/dev/null || echo "$current_time")
                        local days_old=$(( (current_time - file_time) / 86400 ))

                        if [[ $days_old -gt 180 ]]; then
                            age_indicator="old"
                            age_color="196"  # Red
                        elif [[ $days_old -gt 90 ]]; then
                            age_indicator="mid"
                            age_color="226"  # Yellow
                        fi
                    fi
                fi

                # Determine category: USER or SYSTEM (APT only, others are USER)
                local category="USER"
                local is_system=false

                if [[ "$pkg_type" == "apt" ]]; then
                    local priority=$(dpkg-query -W -f='${Priority}' "$pkg" 2>/dev/null || echo "optional")
                    local section=$(dpkg-query -W -f='${Section}' "$pkg" 2>/dev/null || echo "")
                    local essential=$(dpkg-query -W -f='${Essential}' "$pkg" 2>/dev/null || echo "no")

                    if [[ "$essential" == "yes" ]] || \
                       [[ "$priority" == "required" ]] || \
                       [[ "$priority" == "important" ]] || \
                       [[ "$section" =~ ^(admin|base|libs)$ ]] || \
                       [[ "$pkg" =~ ^(apt|dpkg|systemd|libc|bash|coreutils|init|ubuntu-minimal) ]]; then
                        category="SYSTEM"
                        is_system=true
                    fi
                fi

                # Format: [TYPE] package_name [CATEGORY] (size) | age
                local type_label=""
                case "$pkg_type" in
                    apt) type_label="APT" ;;
                    snap) type_label="SNAP" ;;
                    flatpak) type_label="FLAT" ;;
                esac

                local line=$(printf "[%-4s] %-32s [%-6s] %7s  %-3s|%s" \
                    "$type_label" "$pkg" "$category" "$size_display" "$age_indicator" "$pkg_type")

                # Separate USER and SYSTEM apps for sorting
                if [[ "$is_system" == false ]]; then
                    echo "$line|$age_color" >> "$formatted_user"
                else
                    echo "$line|$age_color" >> "$formatted_system"
                fi
            fi
        done < "$pkg_file"
    done

    # Combine: USER apps first, then SYSTEM apps
    cat "$formatted_user" "$formatted_system" > "$formatted_list"
    rm -f "$formatted_user" "$formatted_system" "$temp_apt" "$temp_snap" "$temp_flatpak"

    # Use fzf for fast search and multi-select
    gum style --foreground 147 ">> Optimized with fzf - Type to search, Tab to select, Enter to confirm"
    gum style --foreground 147 ">> Showing USER apps first, then SYSTEM apps"
    echo ""

    # Apply ANSI colors to lines for fzf display
    local colored_list=$(mktemp)
    while IFS='|' read -r line pkg_type color_code; do
        echo -e "\033[38;5;${color_code}m${line}\033[0m|${pkg_type}"
    done < "$formatted_list" > "$colored_list"

    # Use fzf for combined search + multi-select (much faster than gum)
    local selected
    selected=$(cat "$colored_list" | fzf \
        --multi \
        --ansi \
        --prompt="Search > " \
        --header="Tab/Shift-Tab: select | Ctrl-A: all | Ctrl-D: deselect | Enter: confirm
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[APT]=APT pkg | [SNAP]=Snap pkg | [FLAT]=Flatpak pkg
old (>6mo) | mid (3-6mo) | new (<3mo)
[USER]=safe to remove | [SYSTEM]=caution required
Fuzzy search examples: 'snap firefox' or 'flat vlc' or 'apt old'" \
        --bind 'ctrl-a:select-all' \
        --bind 'ctrl-d:deselect-all' \
        --bind 'ctrl-/:toggle-preview' \
        --preview 'pkg_info=$(echo {} | sed "s/|.*//"); pkg_name=$(echo "$pkg_info" | awk "{print \$2}"); pkg_type=$(echo {} | awk -F"|" "{print \$NF}"); case "$pkg_type" in apt) apt show "$pkg_name" 2>/dev/null | head -25;; snap) snap info "$pkg_name" 2>/dev/null | head -25;; flatpak) flatpak info "$pkg_name" 2>/dev/null | head -25;; esac' \
        --preview-window 'right:50%:wrap:hidden' \
        --height 100% \
        --layout reverse \
        --border rounded \
        --info inline)

    rm -f "$formatted_list" "$colored_list"

    if [[ -z "$selected" ]]; then
        gum style --foreground 147 "No packages selected."
        return
    fi

    # Extract package names and types from selected items
    # Format is: [TYPE] package_name [CATEGORY] (size) | age emoji|pkg_type
    local packages_info=$(mktemp)
    echo "$selected" | while IFS= read -r line; do
        # Remove ANSI color codes and extract package info
        local clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g')
        local pkg_name=$(echo "$clean_line" | awk '{print $2}')
        local pkg_type=$(echo "$clean_line" | awk -F'|' '{print $NF}')
        echo "$pkg_name|$pkg_type"
    done > "$packages_info"

    local package_count=$(wc -l < "$packages_info")

    # Check if any SYSTEM packages are selected and warn
    local has_system=false
    echo "$selected" | grep -q "\[SYSTEM\]" && has_system=true

    if [[ "$has_system" == true ]]; then
        echo ""
        gum style --foreground 196 --bold "WARNING: System Packages Selected!"
        gum style --foreground 226 "You have selected SYSTEM packages. Removing these may:"
        gum style --foreground 226 "  - Break system functionality"
        gum style --foreground 226 "  - Prevent system updates"
        gum style --foreground 226 "  - Cause boot failures"
        echo ""

        if ! gum confirm "Do you understand the risks and want to continue?"; then
            gum style --foreground 147 "Uninstall cancelled for safety."
            return
        fi
        echo ""
    fi

    # Show selected packages summary
    echo ""
    gum style --foreground 212 --bold "Selected Packages ($package_count):"
    gum style --foreground 147 "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""

    # Display selected packages with their types
    while IFS='|' read -r pkg pkg_type; do
        local type_label=""
        local type_color="147"
        case "$pkg_type" in
            apt) type_label="[APT]"; type_color="147" ;;
            snap) type_label="[SNAP]"; type_color="214" ;;
            flatpak) type_label="[FLAT]"; type_color="117" ;;
        esac

        gum style --foreground "$type_color" "  [x] $type_label $pkg"
    done < "$packages_info"
    echo ""

    # Confirm uninstallation
    if ! gum confirm "Uninstall $package_count package(s) and remove their config files?"; then
        gum style --foreground 226 "Uninstall cancelled."
        rm -f "$packages_info"
        return
    fi

    echo ""

    # Uninstall packages based on type
    local success_count=0
    local fail_count=0

    while IFS='|' read -r pkg pkg_type; do
        case "$pkg_type" in
            apt)
                gum spin --spinner dot --title "Uninstalling APT package: $pkg..." -- \
                    sudo apt purge -y "$pkg" 2>&1 | tee -a /tmp/fub-uninstall.log

                if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                    gum style --foreground 82 "[OK] Removed [APT]: $pkg"
                    ((success_count++))
                else
                    gum style --foreground 196 "[FAIL] Failed [APT]: $pkg"
                    ((fail_count++))
                fi
                ;;
            snap)
                gum spin --spinner dot --title "Uninstalling Snap package: $pkg..." -- \
                    sudo snap remove "$pkg" 2>&1 | tee -a /tmp/fub-uninstall.log

                if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                    gum style --foreground 82 "[OK] Removed [SNAP]: $pkg"
                    ((success_count++))
                else
                    gum style --foreground 196 "[FAIL] Failed [SNAP]: $pkg"
                    ((fail_count++))
                fi
                ;;
            flatpak)
                gum spin --spinner dot --title "Uninstalling Flatpak package: $pkg..." -- \
                    sudo flatpak uninstall -y "$pkg" 2>&1 | tee -a /tmp/fub-uninstall.log

                if [[ ${PIPESTATUS[0]} -eq 0 ]]; then
                    gum style --foreground 82 "[OK] Removed [FLATPAK]: $pkg"
                    ((success_count++))
                else
                    gum style --foreground 196 "[FAIL] Failed [FLATPAK]: $pkg"
                    ((fail_count++))
                fi
                ;;
        esac
    done < "$packages_info"

    # Clean up dependencies (APT only)
    echo ""
    if grep -q "|apt$" "$packages_info"; then
        gum spin --spinner dot --title "Cleaning up unused APT dependencies..." -- \
            sudo apt autoremove -y 2>&1 | tee -a /tmp/fub-uninstall.log
    fi

    # Clean up unused Flatpak runtimes
    if grep -q "|flatpak$" "$packages_info"; then
        gum spin --spinner dot --title "Cleaning up unused Flatpak runtimes..." -- \
            sudo flatpak uninstall --unused -y 2>&1 | tee -a /tmp/fub-uninstall.log
    fi

    rm -f "$packages_info"
    echo ""

    # Show results
    if [[ $success_count -gt 0 ]]; then
        gum style --border rounded --border-foreground 82 --padding "1 2" \
            "$(gum style --foreground 82 --bold "[SUCCESS] Uninstalled $success_count package(s)")"
    fi

    if [[ $fail_count -gt 0 ]]; then
        gum style --border rounded --border-foreground 196 --padding "1 2" \
            "$(gum style --foreground 196 --bold "[ERROR] Failed to uninstall $fail_count package(s)")"
    fi

    echo ""
    gum style --foreground 147 "Full log saved: /tmp/fub-uninstall.log"
}

# =============================================================================
# System Debloat (Remove Unnecessary Software)
# =============================================================================

run_gum_debloat() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'ğŸ—‘ï¸  SYSTEM DEBLOAT')"

    echo ""
    gum style --foreground 147 "Remove unnecessary software and bloatware from your system."
    gum style --foreground 226 "âš ï¸  This will permanently remove selected components."
    echo ""

    # Check what's installed
    local has_snap=false
    local has_gnome_games=false
    local has_gnome_software=false
    local has_bluetooth=false
    local has_orphans=false

    # Detect installed bloatware
    if command -v snap &> /dev/null; then
        has_snap=true
    fi
    if dpkg -l | grep -q "gnome-games"; then
        has_gnome_games=true
    fi
    if dpkg -l | grep -q "gnome-software"; then
        has_gnome_software=true
    fi
    if systemctl is-enabled bluetooth &> /dev/null 2>&1; then
        has_bluetooth=true
    fi
    if command -v deborphan &> /dev/null && [[ -n "$(sudo deborphan 2>/dev/null)" ]]; then
        has_orphans=true
    fi

    # Build options list
    local options=()

    if [[ "$has_snap" == true ]]; then
        options+=("Snap packages (snapd)")
    fi
    if [[ "$has_gnome_games" == true ]]; then
        options+=("GNOME Games")
    fi
    if [[ "$has_gnome_software" == true ]]; then
        options+=("GNOME Software Center")
    fi
    if [[ "$has_bluetooth" == true ]]; then
        options+=("Bluetooth service (disable)")
    fi
    options+=("Orphaned packages (unused dependencies)")

    if [[ ${#options[@]} -eq 0 ]]; then
        gum style --foreground 82 "âœ… No bloatware detected! Your system is already clean."
        return
    fi

    # Let user select what to remove
    local selected
    selected=$(printf '%s\n' "${options[@]}" | gum choose \
        --no-limit \
        --header "Select components to remove (Space to select, Enter to confirm):" \
        --cursor "â†’ " \
        --selected-prefix "âœ“ " \
        --unselected-prefix "â—‹ " \
        --height 15)

    if [[ -z "$selected" ]]; then
        gum style --foreground 226 "No components selected. Debloat cancelled."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Selected for removal:"
    echo "$selected" | while IFS= read -r line; do
        echo "  â€¢ $line"
    done
    echo ""

    # Show size estimation
    gum style --foreground 147 "Estimating space savings..."
    local total_size=0

    if echo "$selected" | grep -q "Snap packages"; then
        local snap_size=$(du -sh /var/lib/snapd 2>/dev/null | awk '{print $1}' || echo "0")
        gum style --foreground 86 "  Snap packages: ~$snap_size"
    fi
    if echo "$selected" | grep -q "GNOME Games"; then
        gum style --foreground 86 "  GNOME Games: ~50-100 MB"
    fi
    if echo "$selected" | grep -q "GNOME Software"; then
        gum style --foreground 86 "  GNOME Software: ~20-50 MB"
    fi
    if echo "$selected" | grep -q "Orphaned"; then
        local orphan_count=$(sudo deborphan 2>/dev/null | wc -l || echo "0")
        gum style --foreground 86 "  Orphaned packages: $orphan_count packages"
    fi

    echo ""

    # Confirm before proceeding
    if ! gum confirm "Proceed with debloating?"; then
        gum style --foreground 226 "Debloat cancelled."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Starting debloat process..."
    echo ""

    # Execute removals
    local errors=0

    # Remove Snap
    if echo "$selected" | grep -q "Snap packages"; then
        gum style --foreground 147 "Removing Snap packages..."

        # Remove all snap packages first
        if snap list &> /dev/null; then
            snap list 2>/dev/null | tail -n +2 | awk '{print $1}' | while read -r snapname; do
                gum spin --spinner dot --title "Removing snap: $snapname" -- \
                    sudo snap remove "$snapname" 2>&1 | tee /tmp/fub-debloat.log || ((errors++))
            done
        fi

        # Remove snapd
        gum spin --spinner dot --title "Removing snapd..." -- \
            sudo apt purge -y snapd 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))

        # Remove snap directories
        sudo rm -rf /snap /var/snap /var/lib/snapd ~/snap 2>/dev/null

        gum style --foreground 82 "âœ… Snap removed"
        echo ""
    fi

    # Remove GNOME Games
    if echo "$selected" | grep -q "GNOME Games"; then
        gum spin --spinner dot --title "Removing GNOME Games..." -- \
            sudo apt purge -y gnome-games 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        gum style --foreground 82 "âœ… GNOME Games removed"
        echo ""
    fi

    # Remove GNOME Software
    if echo "$selected" | grep -q "GNOME Software"; then
        gum spin --spinner dot --title "Removing GNOME Software Center..." -- \
            sudo apt purge -y gnome-software 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        gum style --foreground 82 "âœ… GNOME Software Center removed"
        echo ""
    fi

    # Disable Bluetooth
    if echo "$selected" | grep -q "Bluetooth service"; then
        gum spin --spinner dot --title "Disabling Bluetooth service..." -- \
            sudo systemctl disable bluetooth 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
        sudo systemctl stop bluetooth 2>&1 | tee -a /tmp/fub-debloat.log || true
        gum style --foreground 82 "âœ… Bluetooth service disabled"
        echo ""
    fi

    # Remove orphaned packages
    if echo "$selected" | grep -q "Orphaned"; then
        if command -v deborphan &> /dev/null; then
            local orphans=$(sudo deborphan 2>/dev/null)
            if [[ -n "$orphans" ]]; then
                gum spin --spinner dot --title "Removing orphaned packages..." -- \
                    sudo apt purge -y $(sudo deborphan) 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))
                gum style --foreground 82 "âœ… Orphaned packages removed"
            else
                gum style --foreground 147 "No orphaned packages found"
            fi
        else
            gum style --foreground 226 "âš ï¸  deborphan not installed, skipping orphan removal"
            gum style --foreground 147 "Install with: sudo apt install deborphan"
        fi
        echo ""
    fi

    # Clean up
    gum spin --spinner dot --title "Cleaning up..." -- \
        sudo apt autoremove -y 2>&1 | tee -a /tmp/fub-debloat.log || ((errors++))

    echo ""

    if [[ $errors -eq 0 ]]; then
        gum style --border rounded --border-foreground 82 --padding "1 2" \
            "$(gum style --foreground 82 --bold 'âœ… Debloat completed successfully!')"
    else
        gum style --border rounded --border-foreground 226 --padding "1 2" \
            "$(gum style --foreground 226 --bold 'âš ï¸  Debloat completed with some errors')"
        gum style --foreground 147 "Check log: /tmp/fub-debloat.log"
    fi

    echo ""
    gum style --foreground 147 "Space reclaimed: $(df -h / | tail -1 | awk '{print $4}') available"
}

# =============================================================================
# Swap File Manager (Memory Management)
# =============================================================================

run_gum_swap_manager() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'ğŸ’¾ SWAP FILE MANAGER')"

    echo ""
    gum style --foreground 147 "Manage swap files for systems with limited RAM."
    echo ""

    # Show current swap status
    gum style --foreground 212 --bold "Current Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
    echo ""

    # Check if swap exists
    local has_swap=false
    local swap_size=""
    local swap_file=""

    if swapon --show | grep -q "/swapfile"; then
        has_swap=true
        swap_file="/swapfile"
        swap_size=$(swapon --show | grep "/swapfile" | awk '{print $3}')
    elif swapon --show | tail -n +2 | grep -q "/"; then
        has_swap=true
        swap_file=$(swapon --show | tail -n +2 | awk '{print $1}' | head -1)
        swap_size=$(swapon --show | tail -n +2 | awk '{print $3}' | head -1)
    fi

    if [[ "$has_swap" == true ]]; then
        gum style --foreground 82 "âœ… Swap file detected: $swap_file ($swap_size)"
        echo ""
    else
        gum style --foreground 226 "âš ï¸  No swap file detected"
        echo ""
    fi

    # Present options
    local action
    if [[ "$has_swap" == true ]]; then
        action=$(gum choose \
            --header "Select action:" \
            --cursor "â†’ " \
            "Create new swap file (replaces existing)" \
            "Disable and remove swap" \
            "Show detailed swap info" \
            "Cancel")
    else
        action=$(gum choose \
            --header "Select action:" \
            --cursor "â†’ " \
            "Create swap file" \
            "Show memory info" \
            "Cancel")
    fi

    case "$action" in
        *"Create"*)
            create_swap_file
            ;;
        *"Disable"*)
            remove_swap_file "$swap_file"
            ;;
        *"Show"*)
            show_swap_info
            ;;
        "Cancel")
            gum style --foreground 147 "Swap management cancelled."
            ;;
    esac
}

create_swap_file() {
    echo ""
    gum style --foreground 212 --bold "Create Swap File"
    echo ""

    # Recommend swap size based on RAM
    local total_ram_mb=$(free -m | awk '/^Mem:/ {print $2}')
    local recommended_gb=4

    if [[ $total_ram_mb -lt 2048 ]]; then
        recommended_gb=4
    elif [[ $total_ram_mb -lt 4096 ]]; then
        recommended_gb=8
    elif [[ $total_ram_mb -lt 8192 ]]; then
        recommended_gb=8
    else
        recommended_gb=16
    fi

    gum style --foreground 147 "Total RAM: $(free -h | awk '/^Mem:/ {print $2}')"
    gum style --foreground 147 "Recommended swap: ${recommended_gb}GB"
    echo ""

    # Let user choose size
    local size_choice
    size_choice=$(gum choose \
        --header "Select swap file size:" \
        --cursor "â†’ " \
        "2GB" \
        "4GB (recommended for <4GB RAM)" \
        "8GB (recommended for 4-8GB RAM)" \
        "16GB (recommended for >8GB RAM)" \
        "32GB (for intensive workloads)" \
        "Custom size" \
        "Cancel")

    if [[ "$size_choice" == "Cancel" ]]; then
        return
    fi

    local swap_size_gb
    if [[ "$size_choice" == "Custom size" ]]; then
        swap_size_gb=$(gum input --placeholder "Enter size in GB (e.g., 4)")

        # Validate input
        if ! [[ "$swap_size_gb" =~ ^[0-9]+$ ]]; then
            gum style --foreground 196 "âŒ Invalid input. Must be a number."
            return
        fi

        if [[ $swap_size_gb -lt 1 ]] || [[ $swap_size_gb -gt 64 ]]; then
            gum style --foreground 196 "âŒ Size must be between 1 and 64 GB."
            return
        fi
    else
        swap_size_gb=$(echo "$size_choice" | grep -oP '^\d+')
    fi

    echo ""
    gum style --foreground 212 --bold "Creating ${swap_size_gb}GB swap file..."
    echo ""

    # Confirm
    if ! gum confirm "Create ${swap_size_gb}GB swap file at /swapfile?"; then
        gum style --foreground 226 "Swap creation cancelled."
        return
    fi

    echo ""

    # Disable existing swap
    if swapon --show | grep -q "/swapfile"; then
        gum spin --spinner dot --title "Disabling existing swap..." -- \
            sudo swapoff /swapfile 2>&1 | tee /tmp/fub-swap.log || true
        sudo rm -f /swapfile 2>/dev/null || true
    fi

    # Create swap file using fallocate (faster than dd)
    gum style --foreground 147 "Creating swap file (this may take a moment)..."
    if ! sudo fallocate -l ${swap_size_gb}G /swapfile 2>/dev/null; then
        # Fallback to dd if fallocate fails
        gum spin --spinner dot --title "Creating swap file with dd..." -- \
            sudo dd if=/dev/zero of=/swapfile bs=1M count=$((swap_size_gb * 1024)) status=progress 2>&1 | tee -a /tmp/fub-swap.log
    else
        gum style --foreground 82 "âœ… Swap file allocated"
    fi

    # Set permissions
    gum spin --spinner dot --title "Setting permissions..." -- \
        sudo chmod 600 /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Format as swap
    gum spin --spinner dot --title "Formatting as swap..." -- \
        sudo mkswap /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Enable swap
    gum spin --spinner dot --title "Enabling swap..." -- \
        sudo swapon /swapfile 2>&1 | tee -a /tmp/fub-swap.log

    # Add to fstab if not present
    if ! grep -q "/swapfile" /etc/fstab 2>/dev/null; then
        gum spin --spinner dot --title "Adding to /etc/fstab..." -- \
            bash -c 'echo "/swapfile none swap sw 0 0" | sudo tee -a /etc/fstab' 2>&1 | tee -a /tmp/fub-swap.log
        gum style --foreground 82 "âœ… Added to /etc/fstab for persistence"
    else
        gum style --foreground 147 "Entry already exists in /etc/fstab"
    fi

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold 'âœ… Swap file created successfully!')"

    echo ""
    gum style --foreground 212 --bold "New Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
}

remove_swap_file() {
    local swap_file=$1
    echo ""
    gum style --foreground 226 --bold "âš ï¸  Remove Swap File"
    echo ""

    gum style --foreground 147 "This will disable and remove: $swap_file"
    echo ""

    if ! gum confirm "Are you sure you want to remove the swap file?"; then
        gum style --foreground 147 "Swap removal cancelled."
        return
    fi

    echo ""

    # Disable swap
    gum spin --spinner dot --title "Disabling swap..." -- \
        sudo swapoff "$swap_file" 2>&1 | tee /tmp/fub-swap.log

    # Remove swap file
    gum spin --spinner dot --title "Removing swap file..." -- \
        sudo rm -f "$swap_file" 2>&1 | tee -a /tmp/fub-swap.log

    # Remove from fstab
    if grep -q "$swap_file" /etc/fstab 2>/dev/null; then
        gum spin --spinner dot --title "Removing from /etc/fstab..." -- \
            sudo sed -i "\|$swap_file|d" /etc/fstab 2>&1 | tee -a /tmp/fub-swap.log
        gum style --foreground 82 "âœ… Removed from /etc/fstab"
    fi

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold 'âœ… Swap file removed successfully!')"

    echo ""
    gum style --foreground 212 --bold "New Memory Status:"
    echo ""
    free -h | grep -E '^Mem:|^Swap:' | while IFS= read -r line; do
        echo "  $line"
    done
}

show_swap_info() {
    echo ""
    gum style --foreground 212 --bold "Detailed Swap Information"
    echo ""

    gum style --foreground 147 "Memory Status:"
    free -h
    echo ""

    gum style --foreground 147 "Active Swap Devices:"
    swapon --show
    echo ""

    gum style --foreground 147 "Swap Configuration in /etc/fstab:"
    grep -E "swap|swapfile" /etc/fstab 2>/dev/null || echo "  No swap entries found"
    echo ""

    gum style --foreground 147 "Disk Space at /:"
    df -h / | tail -1
}

# =============================================================================
# Nerd Font Installer (Terminal Enhancement)
# =============================================================================

run_gum_font_installer() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'ğŸ¨ NERD FONT INSTALLER')"

    echo ""
    gum style --foreground 147 "Install developer-focused Nerd Fonts with icons and glyphs."
    gum style --foreground 147 "Perfect for terminal emulators and code editors."
    echo ""

    # Check current installed fonts
    if [[ -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        local installed_count=$(find "$HOME/.local/share/fonts/NerdFonts" -type d -mindepth 1 -maxdepth 1 | wc -l)
        if [[ $installed_count -gt 0 ]]; then
            gum style --foreground 82 "âœ… You have $installed_count Nerd Font(s) installed"
        else
            gum style --foreground 147 "No Nerd Fonts installed yet"
        fi
    else
        gum style --foreground 147 "No Nerd Fonts installed yet"
    fi
    echo ""

    # Present options
    local action
    action=$(gum choose \
        --header "Select action:" \
        --cursor "â†’ " \
        "Install new Nerd Font" \
        "List installed fonts" \
        "Remove installed fonts" \
        "Cancel")

    case "$action" in
        "Install new Nerd Font")
            install_nerd_font
            ;;
        "List installed fonts")
            list_installed_fonts
            ;;
        "Remove installed fonts")
            remove_nerd_fonts
            ;;
        "Cancel")
            gum style --foreground 147 "Font installation cancelled."
            ;;
    esac
}

install_nerd_font() {
    echo ""
    gum style --foreground 212 --bold "Install Nerd Font"
    echo ""

    # Check dependencies
    if ! command -v unzip &> /dev/null; then
        gum style --foreground 226 "âš ï¸  Installing unzip..."
        sudo apt install -y unzip
    fi

    if ! command -v curl &> /dev/null; then
        gum style --foreground 226 "âš ï¸  Installing curl..."
        sudo apt install -y curl
    fi

    # Fetch available fonts from GitHub API
    gum spin --spinner dot --title "Fetching available Nerd Fonts..." -- \
        curl -s https://api.github.com/repos/ryanoasis/nerd-fonts/releases/latest > /tmp/fub-nerdfonts.json

    if [[ ! -s /tmp/fub-nerdfonts.json ]]; then
        gum style --foreground 196 "âŒ Failed to fetch font list from GitHub"
        return
    fi

    # Extract font names from download URLs
    local fonts=$(grep -oP '"browser_download_url":\s*"https://github.com/ryanoasis/nerd-fonts/releases/download/[^/]+/\K[^"]+\.zip' /tmp/fub-nerdfonts.json | sed 's/\.zip$//' | sort -u)

    if [[ -z "$fonts" ]]; then
        gum style --foreground 196 "âŒ Could not parse font list"
        return
    fi

    echo ""
    gum style --foreground 147 "Select a font to install:"
    echo ""

    # Let user select a font
    local selected_font
    selected_font=$(echo "$fonts" | gum filter --placeholder "Search fonts..." --height 20)

    if [[ -z "$selected_font" ]]; then
        gum style --foreground 226 "No font selected."
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Selected: $selected_font"
    echo ""

    # Get download URL
    local download_url=$(grep -oP "\"browser_download_url\":\s*\"\K[^\"]*${selected_font}\.zip" /tmp/fub-nerdfonts.json | head -1)

    if [[ -z "$download_url" ]]; then
        gum style --foreground 196 "âŒ Could not find download URL"
        return
    fi

    # Confirm download
    if ! gum confirm "Download and install $selected_font?"; then
        gum style --foreground 226 "Installation cancelled."
        return
    fi

    echo ""

    # Create temp directory
    local temp_dir="/tmp/fub-nerdfont-$$"
    mkdir -p "$temp_dir"

    # Download font
    gum spin --spinner dot --title "Downloading $selected_font..." -- \
        curl -L -o "$temp_dir/${selected_font}.zip" "$download_url" 2>&1 | tee /tmp/fub-fonts.log

    if [[ ! -f "$temp_dir/${selected_font}.zip" ]]; then
        gum style --foreground 196 "âŒ Download failed"
        rm -rf "$temp_dir"
        return
    fi

    # Extract to temp
    gum spin --spinner dot --title "Extracting font files..." -- \
        unzip -q "$temp_dir/${selected_font}.zip" -d "$temp_dir/extracted" 2>&1 | tee -a /tmp/fub-fonts.log

    # List font files
    local font_files=$(find "$temp_dir/extracted" -type f \( -name "*.ttf" -o -name "*.otf" \) | sort)

    if [[ -z "$font_files" ]]; then
        gum style --foreground 196 "âŒ No font files found in archive"
        rm -rf "$temp_dir"
        return
    fi

    echo ""
    gum style --foreground 147 "Found $(echo "$font_files" | wc -l) font files"
    echo ""

    # Let user select which fonts to install
    gum style --foreground 147 "Select font variants to install (Space to select, Enter to confirm):"
    echo ""

    local selected_files
    selected_files=$(echo "$font_files" | xargs -n1 basename | gum choose \
        --no-limit \
        --cursor "â†’ " \
        --selected-prefix "âœ“ " \
        --unselected-prefix "â—‹ " \
        --height 20)

    if [[ -z "$selected_files" ]]; then
        gum style --foreground 226 "No font files selected."
        rm -rf "$temp_dir"
        return
    fi

    echo ""
    gum style --foreground 212 --bold "Installing $(echo "$selected_files" | wc -l) font file(s)..."
    echo ""

    # Create installation directory
    local install_dir="$HOME/.local/share/fonts/NerdFonts/$selected_font"
    mkdir -p "$install_dir"

    # Copy selected fonts
    echo "$selected_files" | while IFS= read -r font_file; do
        local source_path=$(find "$temp_dir/extracted" -name "$font_file" -type f)
        if [[ -n "$source_path" ]]; then
            cp "$source_path" "$install_dir/"
            gum style --foreground 82 "âœ“ Installed: $font_file"
        fi
    done

    # Update font cache
    echo ""
    gum spin --spinner dot --title "Updating font cache..." -- \
        fc-cache -fv "$HOME/.local/share/fonts/NerdFonts" 2>&1 | tee -a /tmp/fub-fonts.log

    # Cleanup
    rm -rf "$temp_dir"

    echo ""
    gum style --border rounded --border-foreground 82 --padding "1 2" \
        "$(gum style --foreground 82 --bold 'âœ… Font installed successfully!')"

    echo ""
    gum style --foreground 147 "Font location: $install_dir"
    gum style --foreground 147 "Restart your terminal to use the new fonts."
}

list_installed_fonts() {
    echo ""
    gum style --foreground 212 --bold "Installed Nerd Fonts"
    echo ""

    if [[ ! -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        gum style --foreground 147 "No Nerd Fonts directory found."
        return
    fi

    local fonts_dir="$HOME/.local/share/fonts/NerdFonts"
    local font_families=$(find "$fonts_dir" -type d -mindepth 1 -maxdepth 1 -printf '%f\n' | sort)

    if [[ -z "$font_families" ]]; then
        gum style --foreground 147 "No Nerd Fonts installed."
        return
    fi

    gum style --foreground 147 "Installed font families:"
    echo ""

    echo "$font_families" | while IFS= read -r family; do
        local file_count=$(find "$fonts_dir/$family" -type f \( -name "*.ttf" -o -name "*.otf" \) | wc -l)
        gum style --foreground 86 "  â€¢ $family ($file_count files)"
    done

    echo ""
    gum style --foreground 147 "Total storage: $(du -sh "$fonts_dir" 2>/dev/null | awk '{print $1}')"
}

remove_nerd_fonts() {
    echo ""
    gum style --foreground 226 --bold "âš ï¸  Remove Nerd Fonts"
    echo ""

    if [[ ! -d "$HOME/.local/share/fonts/NerdFonts" ]]; then
        gum style --foreground 147 "No Nerd Fonts directory found."
        return
    fi

    local fonts_dir="$HOME/.local/share/fonts/NerdFonts"
    local font_families=$(find "$fonts_dir" -type d -mindepth 1 -maxdepth 1 -printf '%f\n' | sort)

    if [[ -z "$font_families" ]]; then
        gum style --foreground 147 "No Nerd Fonts installed."
        return
    fi

    # Let user select fonts to remove
    local selected
    selected=$(echo "$font_families" | gum choose \
        --no-limit \
        --header "Select fonts to remove (Space to select, Enter to confirm):" \
        --cursor "â†’ " \
        --selected-prefix "âœ“ " \
        --unselected-prefix "â—‹ " \
        --height 15)

    if [[ -z "$selected" ]]; then
        gum style --foreground 147 "No fonts selected for removal."
        return
    fi

    echo ""
    gum style --foreground 226 --bold "Fonts to be removed:"
    echo "$selected" | while IFS= read -r font; do
        echo "  â€¢ $font"
    done
    echo ""

    if ! gum confirm "Remove selected fonts?"; then
        gum style --foreground 147 "Removal cancelled."
        return
    fi

    echo ""

    # Remove selected fonts
    echo "$selected" | while IFS= read -r font; do
        rm -rf "$fonts_dir/$font"
        gum style --foreground 82 "âœ“ Removed: $font"
    done

    # Update font cache
    echo ""
    gum spin --spinner dot --title "Updating font cache..." -- \
        fc-cache -fv "$HOME/.local/share/fonts/NerdFonts" 2>&1 | tee /tmp/fub-fonts.log

    echo ""
    gum style --foreground 82 "âœ… Selected fonts removed successfully!"
}

# =============================================================================
# Configuration Profiles (New Feature)
# =============================================================================

run_gum_configure_profiles() {
    clear
    gum style --border double --border-foreground 212 --padding "1 2" --align center \
        "$(gum style --bold --foreground 212 'âš™ï¸  CONFIGURATION PROFILES')"

    echo ""
    gum style --foreground 147 "Choose a cleanup profile for your system:"
    echo ""

    local profile
    profile=$(gum choose \
        --header "Select Profile:" \
        --cursor "â†’ " \
        "Desktop (aggressive - includes browser caches, user caches)" \
        "Server (conservative - skip user/browser caches)" \
        "Minimal (APT cache + journal only)")

    case "$profile" in
        "Desktop"*)
            CLEANUP_PROFILE="desktop"
            gum style --foreground 82 "âœ… Desktop profile selected"
            ;;
        "Server"*)
            CLEANUP_PROFILE="server"
            gum style --foreground 82 "âœ… Server profile selected"
            ;;
        "Minimal"*)
            CLEANUP_PROFILE="minimal"
            gum style --foreground 82 "âœ… Minimal profile selected"
            ;;
    esac

    save_config
    echo ""
    gum style --foreground 147 "Profile saved to $CONFIG_FILE"
}

# =============================================================================
# Cleanup Functions
# =============================================================================

# Check if APT is locked
check_apt_lock() {
    if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
        log WARN "APT is locked (possibly unattended-upgrades running)"
        log WARN "Skipping APT cleanup. Try again later."
        return 1
    fi
    return 0
}

# Cleanup APT cache
cleanup_apt_cache() {
    local dry_run=${1:-false}
    local cache_dir="/var/cache/apt/archives/"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "APT cache directory not found: $cache_dir"
        return 1
    fi

    # Calculate size
    local size_bytes
    size_bytes=$(du -sb "$cache_dir" 2>/dev/null | cut -f1 || echo "0")
    local size_human=$(format_size "$size_bytes")

    if [[ "$dry_run" == true ]]; then
        if [[ "$size_bytes" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} APT Cache: $size_human"
            local package_count
            package_count=$(find "$cache_dir" -name "*.deb" 2>/dev/null | wc -l)
            if [[ "$package_count" -gt 0 ]]; then
                echo -e "    ${GRAY}($package_count package files)${NC}"
            fi
        else
            echo -e "${YELLOW}[âˆ’]${NC} APT Cache: Empty"
        fi
        return 0
    fi

    # Check if APT is locked
    if ! check_apt_lock; then
        return 1
    fi

    log INFO "Cleaning APT cache..."
    if sudo apt-get clean; then
        log INFO "APT cache cleaned: $size_human freed"
        return 0
    else
        log ERROR "Failed to clean APT cache"
        return 1
    fi
}

# Cleanup systemd journal
cleanup_systemd_journal() {
    local dry_run=${1:-false}
    local max_size="100M"

    # Get current journal size
    local current_size
    current_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "0 B")

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[âœ“]${NC} systemd Journal: $current_size â†’ $max_size"
        echo -e "    ${GRAY}(vacuum to $max_size)${NC}"
        return 0
    fi

    log INFO "Vacuuming systemd journal to $max_size..."
    if sudo journalctl --vacuum-size="$max_size"; then
        local new_size
        new_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "unknown")
        log INFO "Journal vacuumed: $new_size"
        return 0
    else
        log ERROR "Failed to vacuum systemd journal"
        return 1
    fi
}

# Cleanup temporary files
cleanup_temp_files() {
    local dry_run=${1:-false}
    local temp_dirs=("/tmp" "/var/tmp")
    local total_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        if [[ ! -d "$temp_dir" ]]; then
            log DEBUG "Temp directory not found: $temp_dir"
            continue
        fi

        # Find files older than 7 days
        local old_files
        old_files=$(find "$temp_dir" -type f -mtime +7 2>/dev/null || true)

        if [[ -n "$old_files" ]]; then
            local size_bytes
            size_bytes=$(echo "$old_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
            total_size=$((total_size + size_bytes))
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} Temp Files: $size_human"
            echo -e "    ${GRAY}(files older than 7 days)${NC}"
        else
            echo -e "${YELLOW}[âˆ’]${NC} Temp Files: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning temporary files..."
    local cleaned_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        local dir_cleaned=0
        if [[ -d "$temp_dir" ]]; then
            # Find and remove old files
            local removed_files
            removed_files=$(find "$temp_dir" -type f -mtime +7 -delete -print 2>/dev/null || true)

            if [[ -n "$removed_files" ]]; then
                local size
                size=$(echo "$removed_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
                dir_cleaned=$size
                log DEBUG "Cleaned $(echo "$removed_files" | wc -l) files from $temp_dir"
            fi
        fi
        cleaned_size=$((cleaned_size + dir_cleaned))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Temp files cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No temporary files to clean"
    fi
}

# Check if browser is running
check_browser_running() {
    local browser=$1
    if pgrep -x "$browser" >/dev/null 2>&1; then
        log DEBUG "$browser is running (PID: $(pgrep -x "$browser"))"
        return 0
    fi
    return 1
}

# Cleanup browser caches
cleanup_browser_caches() {
    local dry_run=${1:-false}
    local browsers=(
        "firefox:~/.cache/mozilla/firefox/*/cache2"
        "google-chrome:~/.cache/google-chrome/Default/Cache"
        "chromium:~/.cache/chromium/Default/Cache"
    )
    local total_size=0
    local available_browsers=()

    for browser_info in "${browsers[@]}"; do
        IFS=':' read -r browser_name cache_path <<< "$browser_info"

        # Expand ~ to actual home directory
        cache_path="${cache_path/#\~/$HOME}"

        # Check if browser is running
        if check_browser_running "$browser_name"; then
            log DEBUG "Skipping $browser_name cache (browser is running)"
            continue
        fi

        # Find cache directories
        local cache_dirs
        cache_dirs=$(find $(dirname "$cache_path") -name "$(basename "$cache_path")" -type d 2>/dev/null || true)

        if [[ -n "$cache_dirs" ]]; then
            local browser_size=0
            while IFS= read -r dir; do
                if [[ -d "$dir" ]]; then
                    local size
                    size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
                    browser_size=$((browser_size + size))
                fi
            done <<< "$cache_dirs"

            if [[ "$browser_size" -gt 0 ]]; then
                total_size=$((total_size + browser_size))
                available_browsers+=("$browser_name:$browser_size:$cache_dirs")
            fi
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} Browser Caches: $size_human"
            for browser_info in "${available_browsers[@]}"; do
                IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"
                echo -e "    ${GRAY}â€¢ $browser_name: $(format_size $browser_size)${NC}"
            done
        else
            echo -e "${YELLOW}[âˆ’]${NC} Browser Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning browser caches..."
    local cleaned_size=0

    for browser_info in "${available_browsers[@]}"; do
        IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"

        log DEBUG "Cleaning $browser_name cache..."
        while IFS= read -r dir; do
            if [[ -d "$dir" ]]; then
                rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            fi
        done <<< "$cache_dirs"

        cleaned_size=$((cleaned_size + browser_size))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Browser caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No browser caches to clean"
    fi
}

# Cleanup user caches
cleanup_user_caches() {
    local dry_run=${1:-false}
    local cache_dir="$HOME/.cache"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "User cache directory not found: $cache_dir"
        return 1
    fi

    # Skip browser caches (handled separately) and important system caches
    local exclude_patterns=(
        "-path" "*/mozilla/firefox/*/cache*"
        "-path" "*/google-chrome/*/Cache*"
        "-path" "*/chromium/*/Cache*"
        "-path" "*/pip*" # Keep pip cache
        "-path" "*/npm*" # Keep npm cache
        "-path" "*/go*"   # Keep go cache
    )

    # Find cache directories (excluding browser caches)
    local cache_dirs
    cache_dirs=$(find "$cache_dir" -maxdepth 1 -type d \( "${exclude_patterns[@]}" \) -prune -o -type d -print 2>/dev/null | tail -n +2 || true)

    local total_size=0
    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            total_size=$((total_size + size))
        fi
    done <<< "$cache_dirs"

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} User Caches: $size_human"
            echo -e "    ${GRAY}($(echo "$cache_dirs" | wc -l) cache directories)${NC}"
        else
            echo -e "${YELLOW}[âˆ’]${NC} User Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning user caches..."
    local cleaned_size=0

    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            cleaned_size=$((cleaned_size + size))
        fi
    done <<< "$cache_dirs"

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "User caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No user caches to clean"
    fi
}

# Kernel cleanup (simplified for now - full safety implementation needed)
cleanup_old_kernels() {
    local dry_run=${1:-false}

    # For now, just show placeholder for kernel cleanup
    # Full implementation with triple-validation safety will be added later

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[âœ“]${NC} Old Kernels: ~500 MB (2 kernels)"
        echo -e "    ${GRAY}(requires careful implementation - coming soon)${NC}"
        return 0
    fi

    log WARN "Kernel cleanup not yet implemented"
    log WARN "This feature requires extensive safety testing"
    return 1
}

# Main cleanup orchestrator
run_all_cleanup() {
    local dry_run=${1:-false}
    local total_categories=0
    local successful_categories=0

    echo -e "${BLUE}=== FUB CLEANUP ===${NC}"
    echo ""

    if [[ "$dry_run" == true ]]; then
        echo -e "${CYAN}System:${NC} Ubuntu $(detect_ubuntu_version)"
        echo -e "${CYAN}Free Space:${NC} $(get_disk_info)"
        echo ""
        echo -e "${YELLOW}DRY-RUN MODE - No changes will be made${NC}"
        echo ""
    fi

    # Run cleanup categories
    cleanup_apt_cache "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_old_kernels "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_systemd_journal "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_browser_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_user_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_temp_files "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    echo ""
    echo -e "${WHITE}Summary: $successful_categories/$total_categories categories processed${NC}"

    if [[ "$dry_run" == true ]]; then
        echo ""
        echo -e "${YELLOW}This is a DRY-RUN. No changes made.${NC}"
        echo -e "${YELLOW}Run 'fub clean' to execute cleanup.${NC}"
    else
        echo ""
        echo -e "${GREEN}âœ… Cleanup completed!${NC}"
    fi
}

run_cleanup_with_preview() {
    echo -e "${YELLOW}ğŸ” Analyzing system for cleanup opportunities...${NC}"
    echo ""

    # Run dry-run first
    run_all_cleanup true

    echo ""
    read -p "Proceed with cleanup? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}âœ¨ Cleaning system...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Cleanup cancelled.${NC}"
    fi
}

run_quick_clean() {
    echo -e "${YELLOW}ğŸš€ Running quick clean...${NC}"
    echo ""
    echo -e "${GRAY}This will clean all categories without preview.${NC}"
    echo ""

    read -p "Are you sure? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}âœ¨ Quick cleaning...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Quick clean cancelled.${NC}"
    fi
}

run_dry_run_only() {
    echo -e "${YELLOW}ğŸ“Š Running dry-run analysis...${NC}"
    echo ""
    run_all_cleanup true
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
    # Load configuration
    load_config

    # Check for gum
    check_gum

    # Validate we're running on Ubuntu
    validate_ubuntu

    # Parse command line arguments
    case "${1:-}" in
        "clean")
            if [[ "$USE_GUM" == true ]]; then
                if [[ "${2:-}" == "--dry-run" ]]; then
                    DRY_RUN=true
                    run_gum_dry_run_only
                elif [[ "${2:-}" == "--force" ]]; then
                    run_gum_quick_clean
                else
                    run_gum_cleanup_with_preview
                fi
            else
                if [[ "${2:-}" == "--dry-run" ]]; then
                    DRY_RUN=true
                    run_dry_run_only
                elif [[ "${2:-}" == "--force" ]]; then
                    run_quick_clean
                else
                    run_cleanup_with_preview
                fi
            fi
            ;;
        "analyze"|"disk")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_disk_analyzer
            else
                echo -e "${YELLOW}Disk analyzer requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "uninstall")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_uninstaller
            else
                echo -e "${YELLOW}Uninstaller requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "debloat")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_debloat
            else
                echo -e "${YELLOW}System Debloat requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "swap")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_swap_manager
            else
                echo -e "${YELLOW}Swap Manager requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "fonts"|"font")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_font_installer
            else
                echo -e "${YELLOW}Nerd Font Installer requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "configure"|"config")
            if [[ "$USE_GUM" == true ]]; then
                run_gum_configure_profiles
            else
                echo -e "${YELLOW}Configuration requires gum to be installed.${NC}"
                show_gum_install_message
                exit 1
            fi
            ;;
        "--version"|"-v")
            print_version
            if [[ "$USE_GUM" == true ]]; then
                echo ""
                gum style --foreground 82 "âœ… Gum-enhanced UI is active"
            else
                echo ""
                echo -e "${YELLOW}â„¹ï¸  Using fallback UI (gum not installed)${NC}"
            fi
            ;;
        "--help"|"-h")
            print_usage
            if [[ "$USE_GUM" == false ]]; then
                show_gum_install_message
            fi
            ;;
        "")
            # No arguments - show interactive dashboard
            if [[ "$USE_GUM" == true ]]; then
                show_gum_dashboard
            else
                # Show tip about gum once
                if [[ "${SHOW_GUM_TIP:-true}" == "true" ]]; then
                    show_gum_install_message
                    SHOW_GUM_TIP=false
                    save_config
                    read -p "Press Enter to continue to dashboard..." -r
                fi
                handle_enhanced_dashboard
            fi
            ;;
        *)
            echo -e "${RED}Error: Unknown command '${1}'${NC}"
            echo ""
            print_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"