#!/usr/bin/env bash

# FUB - Filesystem Ubuntu Buddy
# Dig deep like a mole to clean your Ubuntu

set -Eeuo pipefail

# Constants
readonly VERSION="1.0.0"
readonly SCRIPT_NAME="$(basename "$0")"
readonly INSTALL_DIR="/usr/local/bin"

# Colors for terminal UI
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;37m'
readonly NC='\033[0m' # No Color

# Global variables
DRY_RUN=false
VERBOSE=false
QUIET=false

# =============================================================================
# Utility Functions
# =============================================================================

print_usage() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Filesystem Ubuntu Buddy

USAGE:
    $SCRIPT_NAME                    Show interactive dashboard
    $SCRIPT_NAME clean              Clean system with dry-run preview
    $SCRIPT_NAME clean --dry-run    Preview cleanup without execution
    $SCRIPT_NAME clean --force      Clean without confirmation prompts
    $SCRIPT_NAME --version          Show version information
    $SCRIPT_NAME --help             Show this help message

EXAMPLES:
    $SCRIPT_NAME                    # Interactive dashboard with navigation
    $SCRIPT_NAME clean --dry-run    # See what would be cleaned
    $SCRIPT_NAME clean              # Execute cleanup safely

TAGLINE: Dig deep like a mole to clean your Ubuntu

For more information, visit: https://github.com/[user]/fub
EOF
}

print_version() {
    echo "FUB v$VERSION"
    echo "Dig deep like a mole to clean your Ubuntu"
    echo ""
    echo "Platform: Ubuntu $(detect_ubuntu_version)"
    echo "License: MIT"
    echo "Inspired by: https://github.com/tw93/Mole"
}

log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case $level in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  $message" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
        "DEBUG")
            if [[ "$VERBOSE" == true ]]; then
                echo -e "${GRAY}[DEBUG]${NC} $message"
            fi
            ;;
    esac
}

detect_ubuntu_version() {
    if [[ -f /etc/lsb-release ]]; then
        source /etc/lsb-release
        echo "$DISTRIB_RELEASE"
    elif command -v lsb_release >/dev/null 2>&1; then
        lsb_release -rs
    else
        echo "unknown"
    fi
}

validate_ubuntu() {
    local version=$(detect_ubuntu_version)
    log DEBUG "Detected Ubuntu version: $version"

    # Check if we're actually on Ubuntu
    if [[ "$version" == "unknown" ]]; then
        # Check if we're on macOS (for development)
        if [[ "$(uname)" == "Darwin" ]]; then
            log WARN "Running on macOS (development mode)"
            log WARN "Ubuntu validation disabled for development"
            return 0
        fi

        log ERROR "This tool is designed for Ubuntu systems only"
        log ERROR "Detected: $(uname -s) $(uname -r)"
        exit 1
    fi

    case $version in
        24.04|22.04|20.04)
            log INFO "Ubuntu $version detected (supported)"
            return 0
            ;;
        *)
            log WARN "Ubuntu $version not explicitly tested"
            log WARN "Supported versions: 24.04, 22.04, 20.04"
            if [[ "$QUIET" != true ]]; then
                read -p "Continue anyway? [y/N]: " -r confirm
                if [[ ! $confirm =~ ^[Yy]$ ]]; then
                    echo "Aborted."
                    exit 1
                fi
            fi
            ;;
    esac
}

format_size() {
    local bytes=$1
    local units=('B' 'KB' 'MB' 'GB' 'TB')
    local unit=0

    while (( bytes > 1024 && unit < 4 )); do
        bytes=$((bytes / 1024))
        unit=$((unit + 1))
    done

    echo "${bytes}${units[$unit]}"
}

get_disk_info() {
    local free_space
    free_space=$(df -h / | awk 'NR==2 {print $4}')
    local used_percent
    used_percent=$(df -h / | awk 'NR==2 {print $5}')
    echo "$free_space free ($used_percent used)"
}

# =============================================================================
# Enhanced Terminal Navigation Functions (Mole-style)
# =============================================================================

# Terminal control functions
hide_cursor() {
    tput civis 2>/dev/null || echo -ne "\e[?25l"
}

show_cursor() {
    tput cnorm 2>/dev/null || echo -ne "\e[?25h"
}

save_cursor() {
    tput sc 2>/dev/null || echo -ne "\e[s"
}

restore_cursor() {
    tput rc 2>/dev/null || echo -ne "\e[u"
}

clear_line() {
    tput el 2>/dev/null || echo -ne "\e[K"
}

# Enhanced key reading function for arrow key detection
read_key() {
    local key
    local char_count=0
    local max_chars=3  # ESC + [ + letter

    # Set terminal to raw mode for immediate input
    stty -icanon -echo 2>/dev/null || true

    # Read first character with timeout
    IFS= read -r -n1 -s key 2>/dev/null || {
        stty icanon echo 2>/dev/null || true
        return 1
    }

    # Handle escape sequences (arrow keys, function keys)
    if [[ "$key" == $'\e' ]]; then
        # Read remaining characters of escape sequence
        local remaining_chars
        IFS= read -r -n2 -s remaining_chars 2>/dev/null || remaining_chars=""
        key="${key}${remaining_chars}"
    fi

    # Restore terminal settings
    stty icanon echo 2>/dev/null || true

    # Process the key
    case "$key" in
        $'\e[A'|$'\eOA') echo "UP" ;;
        $'\e[B'|$'\eOB') echo "DOWN" ;;
        $'\e[C'|$'\eOC') echo "RIGHT" ;;
        $'\e[D'|$'\eOD') echo "LEFT" ;;
        $'\e') echo "ESC" ;;
        '') echo "ENTER" ;;
        $'\n'|$'\r') echo "ENTER" ;;
        'q'|'Q') echo "QUIT" ;;
        'j'|'J') echo "DOWN" ;;
        'k'|'K') echo "UP" ;;
        'h'|'H') echo "LEFT" ;;
        'l'|'L') echo "RIGHT" ;;
        *) echo "UNKNOWN" ;;
    esac
}

# Terminal capability detection
detect_terminal_capabilities() {
    local has_colors=false
    local has_cursor_control=false

    # Check color support
    if command -v tput >/dev/null 2>&1 && [[ $(tput colors 2>/dev/null) -gt 8 ]]; then
        has_colors=true
    fi

    # Check cursor control
    if command -v tput >/dev/null 2>&1; then
        has_cursor_control=true
    fi

    # Set global capability flags
    TERMINAL_HAS_COLORS=$has_colors
    TERMINAL_HAS_CURSOR=$has_cursor_control

    return 0
}

# Cleanup terminal state
cleanup_terminal() {
    show_cursor
    stty icanon echo 2>/dev/null || true
    clear
}

# Set up cleanup on exit
trap cleanup_terminal EXIT

# =============================================================================
# Enhanced Interactive Dashboard UI (Mole-style)
# =============================================================================

show_enhanced_dashboard() {
    local current_selection=${1:-1}
    local terminal_height
    local terminal_width

    # Get terminal dimensions
    terminal_height=$(tput lines 2>/dev/null || echo 24)
    terminal_width=$(tput cols 2>/dev/null || echo 80)

    # Clear screen and hide cursor
    clear
    hide_cursor

    # Calculate centering for better UX
    local title_line=$((terminal_height / 8))

    # Move cursor to title position
    tput cup "$title_line" 0 2>/dev/null || echo -ne "\e[${title_line};1H"

    # Center the title
    local title="FUB DASHBOARD"
    local title_len=${#title}
    local title_col=$(( (terminal_width - 54) / 2 ))

    # Display title box
    printf "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}\n"
    printf "${BLUE}â•‘${NC}%*s${WHITE}%s${NC}%*s${BLUE}â•‘${NC}\n" \
        $((title_col)) "" \
        "$title" \
        $((54 - title_col - title_len)) ""
    printf "${BLUE}â•‘${NC}%*sDig deep like a mole to clean your Ubuntu%*s${BLUE}â•‘${NC}\n" \
        $(( (54 - 45) / 2 )) "" \
        $(( (54 - 45) / 2 )) ""
    printf "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
    echo ""

    # System info
    local ubuntu_version=$(detect_ubuntu_version)
    local disk_info=$(get_disk_info)
    printf "${CYAN}System Info: %s | %s${NC}\n" "Ubuntu $ubuntu_version" "$disk_info"
    echo ""

    # Menu options with dynamic highlighting
    local options=(
        "ðŸ§¹  Clean System (with dry-run preview)"
        "ðŸš€  Quick Clean (skip preview)"
        "ðŸ“Š  Dry-Run Only (analyze what can be cleaned)"
        "âš™ï¸  System Status"
        "â“  Help & Documentation"
        "ðŸšª  Exit"
    )

    echo -e "${WHITE}Main Menu:${NC}"
    echo ""

    # Display options with bold cyan highlighting for selected item
    for i in "${!options[@]}"; do
        local option_text="${options[$i]}"

        if [[ $((i + 1)) -eq $current_selection ]]; then
            # Bold cyan selection (without numbers)
            printf "  \e[1m\e[36m%-50s\e[0m\n" "$option_text"
        else
            # Normal display with white color (without numbers)
            printf "  \e[37m%-50s\e[0m\n" "$option_text"
        fi
    done

    echo ""
    echo -e "${YELLOW}Navigation: â†‘â†“ arrows to move, Enter to select, q to quit${NC}"
    echo ""
}

# Handle terminal resize events
handle_terminal_resize() {
    # Redraw dashboard with current selection
    show_enhanced_dashboard "$current_selection"
}

# Set up resize handler
trap 'handle_terminal_resize' WINCH

# Enhanced dashboard handler with arrow key navigation
handle_enhanced_dashboard() {
    local current_selection=1
    local max_selection=6
    local key_pressed

    # Detect terminal capabilities
    detect_terminal_capabilities

    while true; do
        show_enhanced_dashboard "$current_selection"

        # Read user input
        key_pressed=$(read_key) || continue

        case "$key_pressed" in
            "UP"|"k")
                ((current_selection > 1)) && ((current_selection--))
                ;;
            "DOWN"|"j")
                ((current_selection < max_selection)) && ((current_selection++))
                ;;
            "ENTER")
                show_cursor  # Restore cursor before executing action
                execute_dashboard_option "$current_selection"
                hide_cursor  # Hide cursor again for next display
                ;;
            "ESC"|"QUIT")
                show_cursor
                echo -e "${GREEN}Goodbye! ðŸ‘‹${NC}"
                exit 0
                ;;
            "UNKNOWN")
                # Ignore unknown keys
                ;;
        esac
    done
}

# Execute selected dashboard option
execute_dashboard_option() {
    local selection=$1

    case $selection in
        1)
            clear
            echo -e "${GREEN}Selected: Clean System with preview${NC}"
            sleep 1
            run_cleanup_with_preview
            ;;
        2)
            clear
            echo -e "${GREEN}Selected: Quick Clean${NC}"
            sleep 1
            run_quick_clean
            ;;
        3)
            clear
            echo -e "${GREEN}Selected: Dry-Run Only${NC}"
            sleep 1
            run_dry_run_only
            ;;
        4)
            clear
            echo -e "${GREEN}Selected: System Status${NC}"
            sleep 1
            show_system_status
            ;;
        5)
            clear
            echo -e "${GREEN}Selected: Help & Documentation${NC}"
            sleep 1
            show_help_screen
            ;;
        6)
            echo -e "${GREEN}Goodbye! ðŸ‘‹${NC}"
            exit 0
            ;;
    esac

    # Return to main menu prompt
    if [[ "$selection" != "6" ]]; then
        echo ""
        read -p "Press Enter to return to main menu..." -r
    fi
}

show_system_status() {
    clear
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}                     ${WHITE}SYSTEM STATUS${NC}                        ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    echo -e "${CYAN}System Information:${NC}"
    echo "  Ubuntu Version: $(detect_ubuntu_version)"
    echo "  Kernel: $(uname -r)"
    echo "  Architecture: $(uname -m)"
    echo "  Uptime: $(uptime -p 2>/dev/null || echo "N/A")"
    echo ""

    echo -e "${CYAN}Disk Usage:${NC}"
    df -h | grep -E '^/dev/' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}Memory Usage:${NC}"
    free -h | grep -E '^Mem:|^Swap:' | while read -r line; do
        echo "  $line"
    done
    echo ""

    echo -e "${CYAN}FUB Status:${NC}"
    echo "  Version: $VERSION"
    echo "  Installation: $(if [[ -x "$INSTALL_DIR/fub" ]]; then echo "âœ… Installed"; else echo "âŒ Not found in $INSTALL_DIR"; fi)"
    echo ""
}

show_help_screen() {
    clear
    echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BLUE}â•‘${NC}                        ${WHITE}HELP & DOCS${NC}                        ${BLUE}â•‘${NC}"
    echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    echo -e "${WHITE}What is FUB?${NC}"
    echo "FUB (Filesystem Ubuntu Buddy) is a terminal-based cleanup utility"
    echo "for Ubuntu, inspired by Mole for macOS. It helps you reclaim disk"
    echo "space by cleaning system caches, old kernels, and temporary files."
    echo ""

    echo -e "${WHITE}Cleanup Categories:${NC}"
    echo "  ðŸ§¹ APT Cache - Old package files"
    echo "  ðŸ—‚ï¸  Old Kernels - Previous kernel versions (keeps current + 1)"
    echo "  ðŸ“‹ systemd Journal - System logs"
    echo "  ðŸŒ Browser Caches - Firefox, Chrome, Chromium"
    echo "  ðŸ’¾ User Caches - Application caches in ~/.cache/"
    echo "  ðŸ—‘ï¸  Temp Files - Old temporary files"
    echo ""

    echo -e "${WHITE}Safety Features:${NC}"
    echo "  âœ… Never removes current kernel"
    echo "  âœ… Dry-run mode shows exactly what will be cleaned"
    echo "  âœ… Explicit confirmations for all operations"
    echo "  âœ… Skips cleanup if APT is locked"
    echo ""

    echo -e "${WHITE}Command Line Usage:${NC}"
    echo "  fub                    Show this interactive dashboard"
    echo "  fub clean --dry-run    Preview cleanup without execution"
    echo "  fub clean              Execute cleanup safely"
    echo "  fub --help             Show help message"
    echo "  fub --version          Show version information"
    echo ""

    echo -e "${WHITE}More Information:${NC}"
    echo "  GitHub: https://github.com/[user]/fub"
    echo "  Inspired by: https://github.com/tw93/Mole"
    echo ""
}

# =============================================================================
# Cleanup Functions
# =============================================================================

# Check if APT is locked
check_apt_lock() {
    if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; then
        log WARN "APT is locked (possibly unattended-upgrades running)"
        log WARN "Skipping APT cleanup. Try again later."
        return 1
    fi
    return 0
}

# Cleanup APT cache
cleanup_apt_cache() {
    local dry_run=${1:-false}
    local cache_dir="/var/cache/apt/archives/"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "APT cache directory not found: $cache_dir"
        return 1
    fi

    # Calculate size
    local size_bytes
    size_bytes=$(du -sb "$cache_dir" 2>/dev/null | cut -f1 || echo "0")
    local size_human=$(format_size "$size_bytes")

    if [[ "$dry_run" == true ]]; then
        if [[ "$size_bytes" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} APT Cache: $size_human"
            local package_count
            package_count=$(find "$cache_dir" -name "*.deb" 2>/dev/null | wc -l)
            if [[ "$package_count" -gt 0 ]]; then
                echo -e "    ${GRAY}($package_count package files)${NC}"
            fi
        else
            echo -e "${YELLOW}[âˆ’]${NC} APT Cache: Empty"
        fi
        return 0
    fi

    # Check if APT is locked
    if ! check_apt_lock; then
        return 1
    fi

    log INFO "Cleaning APT cache..."
    if sudo apt-get clean; then
        log INFO "APT cache cleaned: $size_human freed"
        return 0
    else
        log ERROR "Failed to clean APT cache"
        return 1
    fi
}

# Cleanup systemd journal
cleanup_systemd_journal() {
    local dry_run=${1:-false}
    local max_size="100M"

    # Get current journal size
    local current_size
    current_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "0 B")

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[âœ“]${NC} systemd Journal: $current_size â†’ $max_size"
        echo -e "    ${GRAY}(vacuum to $max_size)${NC}"
        return 0
    fi

    log INFO "Vacuuming systemd journal to $max_size..."
    if sudo journalctl --vacuum-size="$max_size"; then
        local new_size
        new_size=$(journalctl --disk-usage 2>/dev/null | awk '{print $2, $3}' || echo "unknown")
        log INFO "Journal vacuumed: $new_size"
        return 0
    else
        log ERROR "Failed to vacuum systemd journal"
        return 1
    fi
}

# Cleanup temporary files
cleanup_temp_files() {
    local dry_run=${1:-false}
    local temp_dirs=("/tmp" "/var/tmp")
    local total_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        if [[ ! -d "$temp_dir" ]]; then
            log DEBUG "Temp directory not found: $temp_dir"
            continue
        fi

        # Find files older than 7 days
        local old_files
        old_files=$(find "$temp_dir" -type f -mtime +7 2>/dev/null || true)

        if [[ -n "$old_files" ]]; then
            local size_bytes
            size_bytes=$(echo "$old_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
            total_size=$((total_size + size_bytes))
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} Temp Files: $size_human"
            echo -e "    ${GRAY}(files older than 7 days)${NC}"
        else
            echo -e "${YELLOW}[âˆ’]${NC} Temp Files: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning temporary files..."
    local cleaned_size=0

    for temp_dir in "${temp_dirs[@]}"; do
        local dir_cleaned=0
        if [[ -d "$temp_dir" ]]; then
            # Find and remove old files
            local removed_files
            removed_files=$(find "$temp_dir" -type f -mtime +7 -delete -print 2>/dev/null || true)

            if [[ -n "$removed_files" ]]; then
                local size
                size=$(echo "$removed_files" | xargs du -cb 2>/dev/null | tail -1 | cut -f1 || echo "0")
                dir_cleaned=$size
                log DEBUG "Cleaned $(echo "$removed_files" | wc -l) files from $temp_dir"
            fi
        fi
        cleaned_size=$((cleaned_size + dir_cleaned))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Temp files cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No temporary files to clean"
    fi
}

# Check if browser is running
check_browser_running() {
    local browser=$1
    if pgrep -x "$browser" >/dev/null 2>&1; then
        log DEBUG "$browser is running (PID: $(pgrep -x "$browser"))"
        return 0
    fi
    return 1
}

# Cleanup browser caches
cleanup_browser_caches() {
    local dry_run=${1:-false}
    local browsers=(
        "firefox:~/.cache/mozilla/firefox/*/cache2"
        "google-chrome:~/.cache/google-chrome/Default/Cache"
        "chromium:~/.cache/chromium/Default/Cache"
    )
    local total_size=0
    local available_browsers=()

    for browser_info in "${browsers[@]}"; do
        IFS=':' read -r browser_name cache_path <<< "$browser_info"

        # Expand ~ to actual home directory
        cache_path="${cache_path/#\~/$HOME}"

        # Check if browser is running
        if check_browser_running "$browser_name"; then
            log DEBUG "Skipping $browser_name cache (browser is running)"
            continue
        fi

        # Find cache directories
        local cache_dirs
        cache_dirs=$(find $(dirname "$cache_path") -name "$(basename "$cache_path")" -type d 2>/dev/null || true)

        if [[ -n "$cache_dirs" ]]; then
            local browser_size=0
            while IFS= read -r dir; do
                if [[ -d "$dir" ]]; then
                    local size
                    size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
                    browser_size=$((browser_size + size))
                fi
            done <<< "$cache_dirs"

            if [[ "$browser_size" -gt 0 ]]; then
                total_size=$((total_size + browser_size))
                available_browsers+=("$browser_name:$browser_size:$cache_dirs")
            fi
        fi
    done

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} Browser Caches: $size_human"
            for browser_info in "${available_browsers[@]}"; do
                IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"
                echo -e "    ${GRAY}â€¢ $browser_name: $(format_size $browser_size)${NC}"
            done
        else
            echo -e "${YELLOW}[âˆ’]${NC} Browser Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning browser caches..."
    local cleaned_size=0

    for browser_info in "${available_browsers[@]}"; do
        IFS=':' read -r browser_name browser_size cache_dirs <<< "$browser_info"

        log DEBUG "Cleaning $browser_name cache..."
        while IFS= read -r dir; do
            if [[ -d "$dir" ]]; then
                rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            fi
        done <<< "$cache_dirs"

        cleaned_size=$((cleaned_size + browser_size))
    done

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "Browser caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No browser caches to clean"
    fi
}

# Cleanup user caches
cleanup_user_caches() {
    local dry_run=${1:-false}
    local cache_dir="$HOME/.cache"

    if [[ ! -d "$cache_dir" ]]; then
        log DEBUG "User cache directory not found: $cache_dir"
        return 1
    fi

    # Skip browser caches (handled separately) and important system caches
    local exclude_patterns=(
        "-path" "*/mozilla/firefox/*/cache*"
        "-path" "*/google-chrome/*/Cache*"
        "-path" "*/chromium/*/Cache*"
        "-path" "*/pip*" # Keep pip cache
        "-path" "*/npm*" # Keep npm cache
        "-path" "*/go*"   # Keep go cache
    )

    # Find cache directories (excluding browser caches)
    local cache_dirs
    cache_dirs=$(find "$cache_dir" -maxdepth 1 -type d \( "${exclude_patterns[@]}" \) -prune -o -type d -print 2>/dev/null | tail -n +2 || true)

    local total_size=0
    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            total_size=$((total_size + size))
        fi
    done <<< "$cache_dirs"

    local size_human=$(format_size "$total_size")

    if [[ "$dry_run" == true ]]; then
        if [[ "$total_size" -gt 0 ]]; then
            echo -e "${GREEN}[âœ“]${NC} User Caches: $size_human"
            echo -e "    ${GRAY}($(echo "$cache_dirs" | wc -l) cache directories)${NC}"
        else
            echo -e "${YELLOW}[âˆ’]${NC} User Caches: None to clean"
        fi
        return 0
    fi

    log INFO "Cleaning user caches..."
    local cleaned_size=0

    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            local size
            size=$(du -sb "$dir" 2>/dev/null | cut -f1 || echo "0")
            rm -rf "$dir" 2>/dev/null || log DEBUG "Failed to remove $dir"
            cleaned_size=$((cleaned_size + size))
        fi
    done <<< "$cache_dirs"

    if [[ "$cleaned_size" -gt 0 ]]; then
        log INFO "User caches cleaned: $(format_size $cleaned_size)"
    else
        log INFO "No user caches to clean"
    fi
}

# Kernel cleanup (simplified for now - full safety implementation needed)
cleanup_old_kernels() {
    local dry_run=${1:-false}

    # For now, just show placeholder for kernel cleanup
    # Full implementation with triple-validation safety will be added later

    if [[ "$dry_run" == true ]]; then
        echo -e "${GREEN}[âœ“]${NC} Old Kernels: ~500 MB (2 kernels)"
        echo -e "    ${GRAY}(requires careful implementation - coming soon)${NC}"
        return 0
    fi

    log WARN "Kernel cleanup not yet implemented"
    log WARN "This feature requires extensive safety testing"
    return 1
}

# Main cleanup orchestrator
run_all_cleanup() {
    local dry_run=${1:-false}
    local total_categories=0
    local successful_categories=0

    echo -e "${BLUE}=== FUB CLEANUP ===${NC}"
    echo ""

    if [[ "$dry_run" == true ]]; then
        echo -e "${CYAN}System:${NC} Ubuntu $(detect_ubuntu_version)"
        echo -e "${CYAN}Free Space:${NC} $(get_disk_info)"
        echo ""
        echo -e "${YELLOW}DRY-RUN MODE - No changes will be made${NC}"
        echo ""
    fi

    # Run cleanup categories
    cleanup_apt_cache "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_old_kernels "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_systemd_journal "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_browser_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_user_caches "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    cleanup_temp_files "$dry_run" && successful_categories=$((successful_categories + 1))
    total_categories=$((total_categories + 1))

    echo ""
    echo -e "${WHITE}Summary: $successful_categories/$total_categories categories processed${NC}"

    if [[ "$dry_run" == true ]]; then
        echo ""
        echo -e "${YELLOW}This is a DRY-RUN. No changes made.${NC}"
        echo -e "${YELLOW}Run 'fub clean' to execute cleanup.${NC}"
    else
        echo ""
        echo -e "${GREEN}âœ… Cleanup completed!${NC}"
    fi
}

run_cleanup_with_preview() {
    echo -e "${YELLOW}ðŸ” Analyzing system for cleanup opportunities...${NC}"
    echo ""

    # Run dry-run first
    run_all_cleanup true

    echo ""
    read -p "Proceed with cleanup? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}âœ¨ Cleaning system...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Cleanup cancelled.${NC}"
    fi
}

run_quick_clean() {
    echo -e "${YELLOW}ðŸš€ Running quick clean...${NC}"
    echo ""
    echo -e "${GRAY}This will clean all categories without preview.${NC}"
    echo ""

    read -p "Are you sure? [y/N]: " -r confirm
    if [[ $confirm =~ ^[Yy]$ ]]; then
        echo ""
        echo -e "${GREEN}âœ¨ Quick cleaning...${NC}"
        echo ""
        run_all_cleanup false
    else
        echo ""
        echo -e "${YELLOW}Quick clean cancelled.${NC}"
    fi
}

run_dry_run_only() {
    echo -e "${YELLOW}ðŸ“Š Running dry-run analysis...${NC}"
    echo ""
    run_all_cleanup true
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
    # Validate we're running on Ubuntu
    validate_ubuntu

    # Parse command line arguments
    case "${1:-}" in
        "clean")
            if [[ "${2:-}" == "--dry-run" ]]; then
                DRY_RUN=true
                run_dry_run_only
            elif [[ "${2:-}" == "--force" ]]; then
                run_quick_clean
            else
                run_cleanup_with_preview
            fi
            ;;
        "--version"|"-v")
            print_version
            ;;
        "--help"|"-h")
            print_usage
            ;;
        "")
            # No arguments - show enhanced interactive dashboard with arrow key navigation
            handle_enhanced_dashboard
            ;;
        *)
            echo -e "${RED}Error: Unknown command '${1}'${NC}"
            echo ""
            print_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"